<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>软件安全(OWASP以及SD3)</title>
      <link href="posts/e7d67033.html"/>
      <url>posts/e7d67033.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="OWASP"><a href="#OWASP" class="headerlink" title="OWASP"></a>OWASP</h2><h3 id="安全的目标"><a href="#安全的目标" class="headerlink" title="安全的目标"></a>安全的目标</h3><p>•软件安全的目标是要维护信息资源的==<strong>保密性 ，  完整性 ，和 可用性</strong>==，以确保业务的成功运作。该目标通过实施 ==安全控制==来实现。本指南重点介绍具体的技术控制，以 缓解 常见软件 漏洞 的发生。</p><p>•开发团队根据功能需求文档和用例设计一个应用程序以执行特定的任务。</p><p>•而另一方面，攻击者，基于“没有具体说明应拒绝的行为，则被认为是可行的”原则，对于应用程序可以做什么更感兴趣。</p><p>•Web开发团队应当明白，基于客户端的<code>输入验证、隐藏字段和界面控件（例如，下拉键和单选按钮）</code>的客户端控制，所带来的安全性收益是<strong>有限</strong>的。</p><p>•攻击者可以使用工具，比如：客户端的 Web代理（例如，OWASP WebScarab，Burp）或网络数据包捕获工具（例如，Wireshark），进行应用程序流量分析，提交定制的请求，并绕过所有的接口。</p><p>•另外，Flash，JavaApplet 和其它客户端对象可以被反编译并进行漏洞分析。</p><h3 id="软件安全漏洞的产生"><a href="#软件安全漏洞的产生" class="headerlink" title="软件安全漏洞的产生"></a>软件安全漏洞的产生</h3><p>•软件的安全漏洞可以在软件==开发生命周期的任何阶段==被引入</p><p>•最初没有明确的==安全需求==；</p><p>•创建有逻辑错误的==概念设计==；</p><p>•使用糟糕的编码规范，从而带来了==技术漏洞==；</p><p>•软件==部署==不当；</p><p>•在==维护或者更新==过程中引入缺陷。</p><p>此外，还有重要的一点需要明白，==软件漏洞可以超出软件本身的范围==。根据不同的软件、漏洞和配套基础设施的性质，一次成功的攻击会影响下面任何或者所有的方面：</p><p>•软件和其相关的信息；</p><p>•相关服务器的操作系统；</p><p>•后端数据库；</p><p>•在共享环境中的其它应用程序；</p><p>•用户的系统；与用户交互的其它软件。</p><h3 id="12个规则"><a href="#12个规则" class="headerlink" title="12个规则"></a>12个规则</h3><h4 id="1-输入验证"><a href="#1-输入验证" class="headerlink" title="1.输入验证"></a>1.输入验证</h4><p>•在<strong>可信系统</strong>（比如：服务器）上执行所有的数据验证。</p><p>•识别所有的数据源，并将其分为可信的和不可信的。验证所有来自不可信数据源（比如：数据库，文件流，等）的数据。</p><p>•应当为应用程序提供一个集中的输入验证规则。</p><p>•丢弃任何没有通过输入验证的数据。</p><p>•为所有输入明确恰当的字符集，比如：UTF-8。</p><p>•在输入验证前，将数据按照常用字符进行编码（ 规范化 ）。</p><p>•确定系统是否支持 UTF-8扩展字符集，如果支持，在 UTF-8解码完成以后进行输入验证。</p><p>•在处理以前，验证所有来自客户端的数据，包括：所有参数、URL、HTTP头信息（比如：cookie名字和数据值）。确定包括了来自 JavaScript、Flash或其他嵌入代码的 post back信息。</p><p>•验证在请求和响应的报头信息中只含有 ASCII字符。</p><p>•<strong>核实来自重定向输入的数据</strong>（一个攻击者可能向重定向的目标直接提交恶意代码，从而避开应用程序逻辑以及在重定向前执行的任何验证）。</p><p>•验证正确的数据类型。</p><p>•验证数据范围。</p><p>•验证数据长度。</p><p>•尽可能采用“白名单”形式，验证所有的输入。</p><p>•如果任何<strong>潜在的危险字符</strong>必须被作为输入，请确保执行了额外的控制，比如：输出编码、特定的安全 API、以及在应用程序中使用的原因。部分常见的危险字符包括：&lt; &gt; “ ‘ % ( ) &amp; + \ ' " 。</p><p>•如果使用的标准验证规则无法验证下面的输入，那么它们需要被单独验证：<br> o 验证空字节 (%00)；<br> o 验证换行符 (%0d, %0a, \r, \n)；<br> o 验证路径替代字符“点-点-斜杠”（../或 ..\）。如果支持 UTF-8扩展字符集编码，验证替代字符： %c0%ae%c0%ae/ (使用 规范化 验证双编码或其他类型的编码攻击)。</p><h4 id="2-输出编码"><a href="#2-输出编码" class="headerlink" title="2.输出编码"></a>2.输出编码</h4><p>•在可信系统（比如：服务器）上执行所有的编码。</p><p>•为每一种输出编码方法采用一个标准的、已通过测试的规则。</p><p>•通过语义输出编码方式，对所有返回到客户端的来自于应用程序信任边界之外的数据进行编码。HTML实体编码是一个例子，但不是在所有的情况下都可用。</p><p>•除非对目标编译器是安全的，否则请对所有字符进行编码。</p><p>•针对 SQL、XML和 LDAP查询，语义净化所有不可信数据的输出。</p><p>• 对于操作系统命令，净化所有不可信数据输出。</p><h4 id="3-身份验证和密码管理"><a href="#3-身份验证和密码管理" class="headerlink" title="3.身份验证和密码管理"></a>3.身份验证和密码管理</h4><p>•除了那些特定设为“公开”的内容以外，对所有的网页和资源要求身份验证。</p><p>•所有的身份验证过程必须在可信系统（比如：服务器）上执行。</p><p>•在任何可能的情况下，建立并使用标准的、已通过测试的身份验证服务。</p><p>•为所有身份验证控制使用一个集中实现的方法，其中包括利用库文件请求外部身份验证服务。</p><p>•将身份验证逻辑从被请求的资源中隔离开，并使用重定向到或来自集中的身份验证控制。</p><p>•所有的身份验证控制应当安全的处理未成功的身份验证。</p><p>•所有的管理和账户管理功能至少应当具有和主要身份验证机制一样的安全性。</p><p>•只有当所有的数据输入以后，才进行身份验证数据的验证，特别是对连续身份验证机制。</p><p>•身份验证的失败提示信息应当避免过于明确。比如：可以使用“用户名和/或密码错误”，而不要使用“用户名错误”或者“密码错误”。错误提示信息在显示和源代码中应保持一致。</p><p>•为涉及敏感信息或功能的外部系统连接使用身份验证。</p><p>•只使用 HTTP Post 请求传输身份验证的凭据信息。</p><p>•用于访问应用程序以外服务的身份验证凭据信息应当加密，并存储在一个可信系统（比如：服务器）中受到保护的地方。源代码不是一个安全的地方。</p><p>•如果您的应用程序管理着凭证的存储，那么应当保证只保存了通过使用强加密单向 salted哈希算法得到的密码，并且只有应用程序具有对保存密码和密钥的表/文件的写权限（如果可以避免的话，不要使用 MD5算法）。</p><p>•密码哈希必须在可信系统（比如：服务器）上执行。</p><p>•非临时密码只在加密连接中发送或作为加密的数据（比如，一封加密的邮件）。通过邮件重设临时密码可以是一个例外。</p><p>•通过政策或规则加强密码复杂度的要求（比如：要求使用字母、数字和/或特殊符号）。身份验证的凭据信息应当足够复杂以对抗在其所部署环境中的各种威胁攻击。</p><p>•通过政策和规则加强密码长度要求。常用的是 8个字符长度，但是 16个字符长度更好，或者考虑使用多单词密码短语。</p><p>•输入的密码应当在用户的屏幕上模糊显示（比如：在 Web表单中使用“password”输入类型）。</p><p>• 当连续多次登录失败后（比如：通常情况下是 5次），应强制锁定账户。账户锁定的时间必须足够长，以阻止暴力攻击猜测登录信息，但是不能长到允许执行一次拒绝服务攻击。</p><p>•密码重设和更改操作需要类似于账户创建和身份验证的同样控制等级。</p><p>•密码重设问题应当支持尽可能随机的提问（比如：“最喜爱的书”是一个坏的问题，因为《圣经》是最常见的答案）。</p><p>•如果使用基于邮件的重设，只将临时链接或密码发送到预先注册的邮件地址。</p><p>•临时密码和链接应当有一个短暂的有效期。</p><p>•当再次使用临时密码时，强制修改临时密码。</p><p>•当密码重新设置时，通知用户。</p><p>•阻止密码重复使用。</p><p>•密码在被更改前应当至少使用了一天，以阻止密码重用攻击。</p><p>•根据政策或规则的要求，强制定期更改密码。关键系统可能会要求更频繁的更改。更改时间周期必须进行明确。</p><p>•为密码填写框禁用“记住密码”功能。</p><p>•用户账号的上一次使用信息（成功或失败）应当在下一次成功登录时向用户报告。</p><p>•执行监控以确定针对使用相同密码的多用户帐户攻击。当用户 ID可以被得到或被猜到时，该攻击模式用来绕开标准的锁死功能。</p><p>•更改所有厂商提供的默认用户 ID和密码，或者禁用相关帐号。</p><p>•在执行关键操作以前，对用户再次进行身份验证。</p><p>•为高度敏感或重要的交易账户使用多因子身份验证机制。</p><p>•如果使用了第三方身份验证的代码，仔细检查代码以保证其不会受到任何恶意代码的影响。</p><h4 id="4-会话管理"><a href="#4-会话管理" class="headerlink" title="4.会话管理"></a>4.会话管理</h4><p>•使用服务器或者框架的会话管理控制。应用程序应当只识别有效的会话标识符。</p><p>•会话标识符必须总是在一个可信系统（比如：服务器）上创建。</p><p>•会话管理控制应当使用通过审查的算法以保证足够的随机会话标识符。</p><p>•为包含已验证的会话标识符的 cookie设置域和路径，以为站点设置一个恰当的限制值。</p><p>•注销功能应当完全终止相关的会话或连接。</p><p>注销功能应当可用于所有受身份验证保护的网页</p><p>•在平衡的风险和业务功能需求的基础上，设置一个尽量短的会话超时时间。通常情况下，应当不超过几个小时。</p><p>•禁止连续的登录并强制执行周期性的会话终止，即使是活动的会话。特别是对于支持富网络连接或连接到关键系统的应用程序。终止时机应当可以根据业务需求调整，并且用户应当收到足够的通知已减少带来的负面影响。</p><p>•如果一个会话在登录以前就建立，在成功登录以后，关闭该会话并创建一个新的会话。</p><p>•在任何重新身份验证过程中建立一个新的会话标识符。</p><p>•不允许同一用户 ID的并发登录。</p><p>•不要在 URL、错误信息或日志中暴露会话标识符。会话标识符应当只出现在 HTTP cookie头信息中。比如，不要将会话标识符以 GET 参数进行传递。</p><p>•通过在服务器上使用恰当的访问控制，保护服务器端会话数据免受来自服务器其他用户的未授权访问。</p><p>•生成一个新的会话标识符并周期性地使旧会话标识符失效（这可以缓解那些原标识符被获得的特定会话劫持情况）。</p><p>•在身份验证的时候，如果连接从 HTTP变为 HTTPS，则生成一个新的会话标识符。在应用程序中，推荐持续使用 HTTPS，而非在 HTTP和 HTTPS之间转换。</p><p>•为服务器端的操作执行标准的会话管理，比如，通过在每个会话中使用强随机令牌或参数来管理账户。该方法可以用来防止跨站点请求伪造攻击。</p><p>•通过在每个请求或每个会话中使用强随机令牌或参数，为高度敏感或关键的操作提供标准的会话管理。</p><p>•为在 TLS连接上传输的 cookie设置“安全”属性。</p><p>•cookie设置为 HttpOnly属性，除非在应用程序中明确要求了客户端脚本程序读取或者设置cookie的值。</p><h4 id="5-访问控制"><a href="#5-访问控制" class="headerlink" title="5.访问控制"></a>5.访问控制</h4><p>•只使用可信系统对象（比如：服务器端会话对象）以做出访问授权的决定。</p><p>•使用一个单独的全站点部件以检查访问授权。这包括调用外部授权服务的库文件。</p><p>•安全的处理访问控制失败的操作。</p><p>•如果应用程序无法访问其安全配置信息，则拒绝所有的访问。</p><p>•在每个请求中加强授权控制，包括：服务器端脚本产生的请求，“includes”和来自象 AJAX 和FLASH那样的富客户端技术的请求。</p><p>•将有特权的逻辑从其他应用程序代码中隔离开。</p><p>•限制只有授权的用户才能访问文件或其他资源，包括那些应用程序外部的直接控制。</p><p>•限制只有授权的用户才能访问受保护的 URL。</p><p>•限制只有授权的用户才能访问受保护的功能。</p><p>•限制只有授权的用户才能访问直接对象引用。</p><p>•限制只有授权的用户才能访问服务。</p><p>•限制只有授权的用户才能访问应用程序数据。</p><p>•限制通过使用访问控制来访问用户、数据属性和策略信息。</p><p>•限制只有授权的用户才能访问与安全相关的配置信息。</p><p>•服务器端执行的访问控制规则和表示层实施的访问控制规则必须匹配。</p><p>•如果状态数据必须存储在客户端，使用加密算法，并在服务器端检查完整性以捕获状态的改变。</p><p>强制应用程序逻辑流程遵照业务规则。</p><p>•限制单一用户或设备在一段时间内可以执行的事务数量。事务数量/时间应当高于实际的业务需求，但也应该足够低以判定自动化攻击。</p><p>•仅使用“referer”头作为补偿性质的检查，它永远不能被单独用来进行身份验证检查，因为它可以被伪造。</p><p>•如果长的身份验证会话被允许，周期性的重新验证用户的身份，以确保他们的权限没有改变。如果发生改变，注销该用户，并强制他们重新执行身份验证。</p><p>•执行帐户审计并将没有使用的帐号强制失效（比如：在用户密码过期后的 30天以内）。</p><p>•应用程序必须支持帐户失效，并在帐户停止使用时终止会话（比如：角色、职务状况、业务处理的改变，等等）。</p><p>•服务帐户，或连接到或来自外部系统的帐号，应当只有尽可能小的权限。</p><p>• 建立一个“访问控制政策”以明确一个应用程序的业务规则、数据类型和身份验证的标准或处理流程，确保访问可以被恰当的提供和控制。这包括了为数据和系统资源确定访问需求。</p><h4 id="6-加密规范"><a href="#6-加密规范" class="headerlink" title="6.加密规范"></a>6.加密规范</h4><p>•所有用于保护来自应用程序用户秘密信息的加密功能都必须在一个可信系统（比如：服务器）上执行。</p><p>•保护主要秘密信息免受未授权的访问。</p><p>•安全的处理加密模块失败的操作。</p><p>•为防范对随机数据的猜测攻击，应当使用加密模块中已验证的随机数生成器生成所有的随机数、随机文件名、随机 GUID和随机字符串。</p><p>•应用程序使用的加密模块应当遵从 FIPS 140-2或其他等同的标准（请见：<a href="http://csrc.nist.gov/groups/STM/cmvp/validation.html%EF%BC%89%E3%80%82">http://csrc.nist.gov/groups/STM/cmvp/validation.html）。</a></p><p>•建立并使用相关的政策和流程以实现加、解密的密钥管理、错误处理和日志。</p><p>•不要在错误响应中泄露敏感信息，包括：系统的详细信息、会话标识符或者帐号信息。</p><p>•使用错误处理以避免显示调试或堆栈跟踪信息。</p><p>•使用通用的错误消息并使用定制的错误页面。</p><p>•应用程序应当处理应用程序错误，并且不依赖服务器配置。</p><p>•当错误条件发生时，适当的清空分配的内存。</p><p>•在默认情况下，应当拒绝访问与安全控制相关联的错误处理逻辑。</p><p>•所有的日志记录控制应当在可信系统（比如：服务器）上执行。</p><p>•日志记录控制应当支持记录特定安全事件的成功或者失败操作。</p><p>•确保日志记录包含了重要的日志事件数据。</p><p>•确保日志记录中包含的不可信数据，不会在查看界面或者软件时以代码的形式被执行。</p><p>•限制只有授权的个人才能访问日志。</p><p>•为所有的日志记录采用一个主要的常规操作。</p><p>•不要在日志中保存敏感信息，包括：不必要的系统详细信息、会话标识符或密码。</p><p>•确保一个执行日志查询分析机制的存在。</p><p>•记录所有失败的输入验证。</p><p>•记录所有的身份验证尝试，特别是失败的验证。</p><p>•记录所有失败的访问控制。</p><p>•记录明显的修改事件，包括对于状态数据非期待的修改。</p><p>•记录连接无效或者已过期的会话令牌尝试。</p><p>•记录所有的系统例外。</p><p>•记录所有的管理功能行为，包括对于安全配置设置的更改。</p><p>•记录所有失败的后端 TLS链接。</p><p>•记录加密模块的错误。</p><p>•使用加密哈希功能以验证日志记录的完整性。</p><h4 id="7-数据保护"><a href="#7-数据保护" class="headerlink" title="7.数据保护"></a>7.数据保护</h4><p>•授予最低权限，以限制用户只能访问为完成任务所需要的功能、数据和系统信息。</p><p>•保护所有存放在服务器上缓存的或临时拷贝的敏感数据，以避免非授权的访问，并在临时工作文件不再需要时被尽快清除。</p><p>•即使在服务器端，仍然要加密存储的高度机密信息，比如，身份验证的验证数据。总是使用已经被很好验证过的算法，更多指导信息请参见“加密规范”部分。</p><p>•保护服务器端的源代码不被用户下载。</p><p>•不要在客户端上以明文形式或其他非加密安全模式保存密码、连接字符串或其他敏感信息。这包括嵌入在不安全的形式中：MS viewstate、Adobe flash 或者已编译的代码。</p><p>•删除用户可访问产品中的注释，以防止泄露后台系统或者其他敏感信息。</p><p>•删除不需要的应用程序和系统文档，因为这些也可能向攻击者泄露有用的信息。</p><p>•不要在 HTTP GET请求参数中包含敏感信息。</p><p>•禁止表单中的自动填充功能，因为表单中可能包含敏感信息，包括身份验证信息。</p><p>•禁止客户端缓存网页，因为可能包含敏感信息。“Cache-Control: no-store”，可以和 HTTP报头控制“Pragma: no-cache”一起使用，该控制不是非常有效，但是与 HTTP/1.0向后兼容。</p><p>•应用程序应当支持，当数据不再需要的时候，删除敏感信息（比如：个人信息或者特定财务数据）。</p><p>•为存储在服务器中的敏感信息提供恰当的访问控制。这包括缓存的数据、临时文件以及只允许特定系统用户访问的数据。</p><h4 id="8-通讯安全"><a href="#8-通讯安全" class="headerlink" title="8.通讯安全"></a>8.通讯安全</h4><p>•为所有敏感信息采用加密传输。其中应该包括使用 TLS对连接的保护，以及支持对敏感文件或非基于 HTTP连接的不连续加密。</p><p>•TLS证书应当是有效的，有正确且未过期的域名，并且在需要时，可以和中间证书一起安装。</p><p>•没有成功的 TLS连接不应当后退成为一个不安全的连接。</p><p>•为所有要求身份验证的访问内容和所有其他的敏感信息提供 TLS连接。</p><p>•为包含敏感信息或功能、且连接到外部系统的连接使用 TLS。</p><p>•使用配置合理的单一标准 TLS连接。</p><p>•为所有的连接明确字符编码。</p><p>•当链接到外部站点时，过滤来自 HTTP referer 中包含敏感信息的参数。</p><h4 id="9-系统配置"><a href="#9-系统配置" class="headerlink" title="9.系统配置"></a>9.系统配置</h4><p>•确保服务器、框架和系统部件采用了认可的最新版本。</p><p>•确保服务器、框架和系统部件安装了当前使用版本的所有补丁。</p><p>•关闭目录列表功能。</p><p>•将 Web服务器、进程和服务的账户限制为尽可能低的权限。</p><p>•当例外发生时，安全的进行错误处理。</p><p>•移除所有不需要的功能和文件。</p><p>在部署前，移除测试代码和产品不需要的功能。</p><p>•通过将不进行对外检索的路径目录放在一个隔离的父目录里，以防止目录结构在 robots.txt文档中暴露。然后，在 robots.txt 文档中“禁止”整个父目录，而不是对每个单独目录的“禁止”。</p><p>•明确应用程序采用哪种 HTTP方法：GET 或 POST，以及是否需要在应用程序不同网页中以不同的方式进行处理。</p><p>•禁用不需要的 HTTP方法，比如 WebDAV 扩展。如果需要使用一个扩展的 HTTP方法以支持文件处理，则使用一个好的经过验证的身份验证机制。</p><p>•如果 Web服务器支持 HTTP1.0和 1.1，确保以相似的方式对它们进行配置，或者确保您理解了它们之间可能存在差异（比如：处理扩展的 HTTP方法）。</p><p>•移除在 HTTP相应报头中有关 OS、Web服务版本和应用程序框架的无关信息。</p><p>•应用程序存储的安全配置信息应当可以以可读的形式输出，以支持审计。</p><p>•使用一个资产管理系统，并将系统部件和软件注册在其中。</p><p>•将开发环境从生成网络隔离开，并只提供给授权的开发和测试团队访问。开发环境往往没有实际生成环境那么安全，攻击者可以使用这些差别发现共有的弱点或者是可被利用的漏洞。</p><p>•使用一个软件变更管理系统以管理和记录在开发和产品中代码的变更。</p><p>•数据库安全：</p><p>•使用强类型的参数化查询方法。</p><p>•使用输入验证和输出编码，并确保处理了元字符。如果失败，则不执行数据库命令。</p><p>•确保变量是强类型的。</p><p>•当应用程序访问数据库时，应使用尽可能最低的权限。</p><p>•为数据库访问使用安全凭证。</p><p>•连接字符串不应当在应用程序中硬编码。连接字符串应当存储在一个可信服务器的独立配置文件中，并且应当被加密。</p><p>•使用存储过程以实现抽象访问数据，并允许对数据库中表的删除权限。</p><p>•尽可能地快速关闭数据库连接。</p><p>•删除或者修改所有默认的数据库管理员密码。使用强密码、强短语，或者使用多因子身份验证。</p><p>•关闭所有不必要的数据库功能（比如：不必要的存储过程或服务、应用程序包、仅最小化安装需要的功能和选项</p><p>•删除厂商提供的不必要的默认信息（比如：数据库模式示例）。</p><p>•禁用任何不支持业务需求的默认帐户。</p><p> 应用程序应当以不同的凭证为每个信任的角色（比如：用户、只读用户、访问用户、管理员）连接数据库。</p><h4 id="10-文件管理"><a href="#10-文件管理" class="headerlink" title="10.文件管理"></a>10.文件管理</h4><p>•不要把用户提交的数据直接传送给任何动态调用功能。</p><p>•在允许上传一个文档以前进行身份验证。</p><p>•只允许上传满足业务需要的相关文档类型。</p><p>•通过检查文件报头信息，验证上传文档是否是所期待的类型。只验证文件类型扩展是不够的。</p><p>•不要把文件保存在与应用程序相同的 Web环境中。文件应当保存在内容服务器或者数据库中。</p><p>•防止或限制上传任意可能被 Web服务器解析的文件。</p><p>•关闭在文件上传目录的运行权限。</p><p>•通过装上目标文件路径作为使用了相关路径或者已变更根目录环境的逻辑盘，在 UNIX 中实现安全的文件上传服务。</p><p>•当引用已有文件时，使用一个白名单记录允许的文件名和类型。</p><p>•验证传递的参数值，如果与预期的值不匹配，则拒绝使用，或者使用默认的硬编码文件值代替。</p><p>•不要将用户提交的数据传递到动态重定向中。如果必须允许使用，那么重定向应当只接受通过验证的相对路径 URL。</p><p>•不要传递目录或文件路径，使用预先设置路径列表中的匹配索引值。</p><p>•绝对不要将绝对文件路径传递给客户。</p><p>•确保应用程序文件和资源是只读的。</p><p>• 对用户上传的文件扫描进行病毒和恶意软件。</p><h4 id="11-内存管理"><a href="#11-内存管理" class="headerlink" title="11.内存管理"></a>11.内存管理</h4><p>•对不可信数据进行输入和输出控制。</p><p>•重复确认缓存空间的大小是否和指定的大小一样。</p><p>•当使用允许多字节拷贝的函数时，比如 strncpy()，如果目的缓存容量和源缓存容量相等时，需要留意字符串没有 NULL终止。</p><p>•如果在循环中调用函数时，检查缓存大小，以确保不会出现超出分配空间大小的危险。</p><p>•在将输入字符串传递给拷贝和连接函数前，将所有输入的字符串缩短到合理的长度。</p><p>•关闭资源时要特别注意，不要依赖垃圾回收机制（比如：连接对象、文档处理，等）。</p><p>•在可能的情况下，使用不可执行的堆栈。</p><p>•避免使用已知有漏洞的函数（比如：printf，strcat，strcpy，等）。</p><p>•当方法结束时和在所有的退出节点时，正确地清空所分配的内存。</p><h4 id="12-通用编码规范"><a href="#12-通用编码规范" class="headerlink" title="12.通用编码规范"></a>12.通用编码规范</h4><p>•为常用的任务使用已测试且已认可的托管代码，而不创建新的非托管代码。</p><p>•使用特定任务的内置 API以执行操作系统的任务。不允许应用程序直接将代码发送给操作系统，特别是通过使用应用程序初始的命令 shell。</p><p>•使用校验和或哈希值验证编译后的代码、库文件、可执行文件和配置文件的完整性。</p><p>•使用死锁来防止多个同时发送的请求，或使用一个同步机制防止竞态条件。</p><p>•在同时发生不恰当的访问时，保护共享的变量和资源。</p><p>•在声明时或在第一次使用前，明确初始化的所有变量和其他数据存储。</p><p>•当应用程序运行发生必须提升权限的情况时，尽量晚点提升权限，并且尽快放弃所提升的权限。</p><p>•通过了解您使用的编程语言的底层表达式以及它们是如何进行数学计算，从而避免计算错误。密切注意字节大小依赖、精确度、有无符合、 截尾操作、转换、字节之间的组合、“not-a-number”计算、以及对于编程语言 底层表达式 如何处理非常大或者非常小的数。</p><p>•不要将用户提供的数据传递给任何动态运行的功能。</p><p>•限制用户生成新代码或更改现有代码。</p><p>•审核所有从属的应用程序、第三方代码和库文件，以确定业务的需要，并验证功能的安全性，因为它们可能产生新的漏洞。</p><p>•执行安全更新。如果应用程序采用自动更新，则为您的代码使用加密签名，以确保的您的下载客户端验证这些签名。使用加密的信道传输来自主机服务器的代码。</p><h2 id="SD3"><a href="#SD3" class="headerlink" title="SD3"></a>SD3</h2><h3 id="安全设计"><a href="#安全设计" class="headerlink" title="安全设计"></a>安全设计</h3><p>•安排具体的安全设计的人员；</p><p>•进行安全教育；</p><p>•确保威胁分析已经完成；</p><p>•符合安全设计和编码的指导原则；</p><p>•尽可能修补任何安全编程指南上的BUG;</p><p>•确保安全指南是逐步改进的；</p><p>•针对已经修复的缺陷开发回归测试；</p><p>•简化代码和安全模型；</p><p>•在打包以前完成穿透测试。</p><h3 id="缺省安全"><a href="#缺省安全" class="headerlink" title="缺省安全"></a>缺省安全</h3><p>•缺省状态下，不要设置所有的特点和功能；</p><p>•允许最小权限；</p><p>•恰当的资源保护。</p><h3 id="安全提交"><a href="#安全提交" class="headerlink" title="安全提交"></a>安全提交</h3><p>•确认程序给管理员提供了安全功能；</p><p>•尽可能提供高质量的补丁；</p><p>•提供足够的信息以使用户安全的使用软件。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 软件安全 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>软件测试知识点汇总</title>
      <link href="posts/748fe819.html"/>
      <url>posts/748fe819.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="软件测试"><a href="#软件测试" class="headerlink" title="软件测试"></a>软件测试</h2><h2 id="PPT概念"><a href="#PPT概念" class="headerlink" title="PPT概念"></a>PPT概念</h2><p><img src="https://s2.loli.net/2022/05/24/CVKB5SWIGyboDcH.png"></p><p><img src="https://s2.loli.net/2022/05/24/TtAmV1hjuXNiZpn.png"></p><p><img src="https://s2.loli.net/2022/05/24/z8Xxo1OF6Ug2nQe.png"></p><p><img src="https://s2.loli.net/2022/05/24/9MC3leGAUfyxNmB.png"></p><p><img src="https://s2.loli.net/2022/05/24/3bfaAh2YRTkGid4.png"></p><p><img src="https://s2.loli.net/2022/05/24/Igy3s1w5x79JDcH.png"></p><p><img src="https://s2.loli.net/2022/05/24/ATGMFtlPKXxkvEV.png"></p><p><img src="https://s2.loli.net/2022/05/24/aMFDlpzwObr9VNo.png"></p><p><img src="https://s2.loli.net/2022/05/24/iAd8gceFNyatC9l.png"></p><p><img src="https://s2.loli.net/2022/05/24/FGdRUOvr479mqca.png"></p><p><img src="https://s2.loli.net/2022/05/24/rugsHYqGPD8OpJC.png"></p><p><img src="https://s2.loli.net/2022/05/24/zaThYWHXwElMJIZ.png" alt="1653284291563.png"></p><p><img src="https://s2.loli.net/2022/05/24/lcrtNx48zjmLXZo.png" alt="1653284422463.png"></p><p><strong>注意敏捷测试和传统测试的区别:</strong></p><p><code>敏捷测试:强调整个团队对测试负责(无测试的独立性);连续测试,连续的质量反馈,阶段性弱;注重速度和适应性,不断适应需求变化;强调团队之间面对面沟通,不注重对缺陷的跟踪和记录;始终以用户需求为中心,将验证和确认统一起来;注重产品本身和产品的客户价值,缺陷修复的代价小;自动化测试是敏捷测试的基础.</code></p><p><code>传统测试:独立性、阶段性明显、计划性、缺陷的跟踪和记录、由验证和确认两种活动组成、缺陷修复代价大（相关文档等等），鼓励自动化测试，但不自动化测试也不致命</code></p><p><img src="https://s2.loli.net/2022/05/24/cOD3s6RGE2QaCWg.png"></p><p><img src="https://s2.loli.net/2022/05/24/I7Otp5hVQDufJSv.png"> </p><p><img src="https://s2.loli.net/2022/05/24/rQ4Gzyxsch1wIO2.png"></p><p><img src="https://s2.loli.net/2022/05/24/AGy9TEUoWQMHfeL.png"></p><p><img src="https://s2.loli.net/2022/05/24/nKfxZPgGt568VMQ.png"></p><p><img src="https://s2.loli.net/2022/05/24/MRwlnVAzvscNTqm.png" alt="1653284390335.png"></p><p>阶段:计划与控制  基础设施建立 准备 说明 执行 完成</p><p><img src="https://s2.loli.net/2022/05/24/Licmpgh5tORuwXd.png"></p><p><img src="https://s2.loli.net/2022/05/24/Wz4RDruo6BynmAO.png"></p><h3 id="集成测试"><a href="#集成测试" class="headerlink" title="集成测试"></a>集成测试</h3><p><img src="https://s2.loli.net/2022/05/24/5OtVPE918cXRaUm.png"></p><h3 id="JUnit单元测试"><a href="#JUnit单元测试" class="headerlink" title="JUnit单元测试"></a>JUnit单元测试</h3><p><img src="https://s2.loli.net/2022/05/24/4r16gocumk32sIU.png"></p><p><img src="https://s2.loli.net/2022/05/24/RpbthnKMaqjLeiN.png"></p><p><img src="https://s2.loli.net/2022/05/24/K2f7cVTrHmRhCzk.png"></p><p><img src="https://s2.loli.net/2022/05/24/s5qvcHD6EGXpFPW.png"></p><p><img src="https://s2.loli.net/2022/05/24/CLNQ14ohRlObeg8.png"></p><p><img src="https://s2.loli.net/2022/05/24/2MWIQYdpJqvo3m4.png"></p><p><img src="https://s2.loli.net/2022/05/24/WO36d21RCgvuNUe.png"></p><p><img src="https://s2.loli.net/2022/05/24/7hOXFHVZvTzpifr.png"></p><p><img src="https://s2.loli.net/2022/05/24/XMubS7c2PGiQ1oN.png"></p><p><img src="https://s2.loli.net/2022/05/24/cT96jMX18vPeUwB.png"></p><p><img src="https://s2.loli.net/2022/05/24/x64n8yHovB59lfT.png"></p><p><img src="https://s2.loli.net/2022/05/24/JeWbcliyo5hdKft.png"></p><p><img src="https://s2.loli.net/2022/05/24/neLcHrXfa9iQ6js.png"></p><p><img src="https://s2.loli.net/2022/05/24/YXIPVZB8af19tnE.png"></p><h2 id="一些习题"><a href="#一些习题" class="headerlink" title="一些习题"></a>一些习题</h2><table><thead><tr><th>CM1CM2</th><th></th><th></th><th></th><th></th></tr></thead><tbody><tr><td>下面哪项活动不在<strong>软件测试</strong>范围 ？</td><td>A.需求文档评审</td><td>B.设计评审</td><td>C.代码测试</td><td><strong>D.过程评审</strong></td></tr><tr><td>软件测试的对象包括</td><td>A.目标程序和相关文档</td><td><strong>B.源程序、目标程序、数据及相关文档</strong></td><td>C.目标程序、操作系统和平台软件</td><td>D.源程序和目标程序</td></tr><tr><td>在软件开发接近完成时，执行下面哪种测试？</td><td>A.验收测试</td><td>B.α测试</td><td>C.β测试</td><td>D.系统测试</td></tr><tr><td>软件测试类型按开发阶段划分为</td><td>A.需求、单元、集成、验证测试</td><td><strong>B.单元、集成、系统、验收测试</strong></td><td>C.单元、集成、确认、验收测试</td><td>D.调试、单元、集成、用户测试</td></tr><tr><td>在软件质量模型中，<strong>可维护性属性</strong>不包括下面哪个子特性</td><td>A.适应性</td><td>B.易安装性</td><td><strong>C.兼容性</strong></td><td>D.一致性</td></tr><tr><td>软件质量是指</td><td>A.软件具有功能性 可靠性</td><td>B.最大限度满足用户需求</td><td>C.软件没有错误</td><td><strong>D.软件满足用户需求的能力</strong></td></tr><tr><td></td><td>可维护性 可移植性</td><td></td><td></td><td><strong>和产品的固有特性</strong></td></tr><tr><td>在所有软件缺陷中，哪类缺陷比例最高？</td><td>A.程序代码错误</td><td>B.软件设计错误</td><td><strong>C.需求分析错误</strong></td><td>D.其它</td></tr><tr><td>修复哪个阶段的软件缺陷，其成本最<strong>低？</strong></td><td><strong>A.需求分析阶段</strong></td><td>B.系统设计阶段</td><td>C.程序编码阶段</td><td>D.软件发布阶段</td></tr><tr><td>最基础的软件测试是什么？</td><td>A.静态测试</td><td>B.动态测试</td><td><strong>C.单元测试</strong></td><td>D.集成测试</td></tr><tr><td>软件测试的主要目的是</td><td></td><td></td><td></td><td></td></tr><tr><td>CM3</td><td></td><td></td><td></td><td></td></tr><tr><td>下面哪个方法属于白盒测试方法？</td><td><strong>A.路径测试</strong></td><td>B.等价类</td><td>C.因果图</td><td>D.归纳测试</td></tr><tr><td>等价类划分法设计8位宽度数字类型数据作用户登录账号，有多少种测试用例方案？</td><td>A.2</td><td>B.3</td><td>C.4</td><td>D.6</td></tr><tr><td>假定X为整数类型变量，X&gt;=1并且X&lt;=10，采用边界值法进行测试，其方案是</td><td>A.1，10</td><td>B.0，1，10，11</td><td><strong>C.0，1，2，9，10，11</strong></td><td>D.0，11</td></tr><tr><td>根据输出对输入的依赖关系设计测试用例的方法是</td><td>A.路径测试</td><td>B.等价类</td><td><strong>C.因果图</strong></td><td>D.归纳测试</td></tr><tr><td>在黑盒测试中，着重检查输入条件组合的方法是</td><td>A.等价类划分法</td><td>B.边界值分析法</td><td>C.错误推测法</td><td><strong>D.判定表法</strong></td></tr><tr><td>不属于白盒测试的技术是</td><td><strong>A.判定表法</strong></td><td>B.判定覆盖</td><td>C.条件覆盖</td><td>D.路径覆盖</td></tr><tr><td>下面那种方法能够有效地检测输入<strong>条件</strong>的各种组合可能引起的错误</td><td>A.错误推测</td><td>B.等价类划分</td><td>C.判定覆盖</td><td><strong>D.因果图</strong></td></tr><tr><td>以下哪种方法不是黑盒测试用例的设计方法</td><td>A.场景法</td><td>B.边界值法</td><td>C.因果图法</td><td><strong>D.路径法</strong></td></tr><tr><td>下列几种逻辑覆盖标准中，查错能力最强的是</td><td>A.语句覆盖</td><td>B.判定覆盖</td><td>C.条件覆盖</td><td><strong>D.条件组合覆盖</strong></td></tr><tr><td>发现错误能力最弱的是</td><td><strong>A.语句覆盖</strong></td><td>B.判定覆盖</td><td>C.条件覆盖</td><td>D.路径覆盖</td></tr><tr><td>查找程序是否有内存泄露，可采用的软件测试是</td><td>A.静态测试</td><td><strong>B.动态测试</strong></td><td>C.单元测试</td><td>D.集成测试</td></tr><tr><td>CM4</td><td></td><td></td><td></td><td></td></tr><tr><td>从<strong>软件工程角度</strong>，软件测试分为几个阶段。</td><td>A.3</td><td>B.4</td><td>C.5</td><td><strong>D.6</strong></td></tr><tr><td>在W模型中，程序设计与下面哪项测试可以同步？</td><td>A.需求评审</td><td>B.设计评审</td><td><strong>C.功能测试用例设计</strong></td><td>D.单元测试</td></tr><tr><td>当软件开发机构具有独立的测试部门，该机构测试成熟度至少达到下面哪个级别？</td><td>A.TMM2</td><td><strong>B.TMM3</strong></td><td>C.TMM4</td><td>D.TMM5</td></tr><tr><td>按照软件测试规范，执行单元测试是由哪类人员来进行？</td><td>A.测试分析人员</td><td>B.测试人员</td><td>C.设计人员</td><td><strong>D.编程人员</strong></td></tr><tr><td>下面哪项不属于<strong>测试项目管理的</strong>内容</td><td>A.测试设计</td><td><strong><em>B.单元测试</em></strong></td><td><strong>C.测试执行</strong></td><td>D.测试结果分析</td></tr><tr><td>按照软件测试规范，在以下<strong>哪个测试阶段</strong>制定测试策略？</td><td><strong><em>A.测试计划</em></strong></td><td><strong>B.测试设计</strong></td><td>C.测试实施</td><td>D.测试评估</td></tr><tr><td>按照软件测试规范，下面哪项评审需要项目经理参加？</td><td><strong>A.测试计划评审</strong></td><td>B.测试用例评审</td><td>C.测试过程评审</td><td>D.测试结果评估</td></tr><tr><td>在敏捷测试中，应主要采用探索式测试</td><td>对</td><td></td><td></td><td></td></tr><tr><td>在软件开发的  W模型中，测试过程与开发过程同步进行</td><td>对</td><td></td><td></td><td></td></tr><tr><td>测试结果的评估应由SQA人员来完成</td><td>错</td><td></td><td></td><td></td></tr><tr><td>CM5</td><td></td><td></td><td></td><td></td></tr><tr><td>下面哪个测试内容不属于单元测试（  ）</td><td>A.接口数据测试</td><td>B.局部数据测试</td><td><strong>C.模块间时序测试</strong></td><td>D.全局数据测试</td></tr><tr><td>以下关于集成测试的正确描述是（）</td><td>A.在把各个模块连接起来的时候，</td><td>B.一个模块的功能是否会对另一个模块</td><td>C.全局数据结构是否有问题</td><td><strong>D.以上都是</strong></td></tr><tr><td></td><td>穿越模块接口的数据是否会丢失</td><td>的功能产生不利的影响</td><td></td><td></td></tr><tr><td>在集成测试时，能较早发现高层模块接口错误的测试方法为。</td><td><strong>A.自顶向下渐增式测试</strong></td><td>B.自底向上渐增式测试</td><td>C.非渐增式测试</td><td>D.系统测试</td></tr><tr><td>Web应用系统负载测试中，以下哪个不是衡量业务执行效率的指标。</td><td>A.事务并发请求数</td><td><strong>B.CPU执行占用率</strong></td><td>C.事务吞吐量</td><td>D.事务响应时间</td></tr><tr><td>性能测试脚本执行，是在性能测试过程的第几阶段实施。</td><td>A.2</td><td>B.3</td><td><strong>C.4</strong></td><td>D.5</td></tr><tr><td>以下哪类系统可靠性最高。</td><td>A.单机系统</td><td>B.C/S系统</td><td>C.B/S系统</td><td><strong>D.P2P系统</strong></td></tr><tr><td>验证系统部件失效后的处理能力是属于以下哪种测试</td><td>A.系统性能测试</td><td>B.系统可靠性测试</td><td><strong>C.系统容错测试</strong></td><td>D.系统功能测试</td></tr><tr><td>下面哪种负载模式更接近实际系统运行情况</td><td>A.一次性加载</td><td>B.递增加载</td><td>C.高低变更加载</td><td><strong>D.随机加载</strong></td></tr><tr><td>下面哪种情况不是导致系统性能问题的原因</td><td>A.CPU使用率过高</td><td>B.内存泄露</td><td><strong>C.系统响应时间长</strong></td><td>D.连接资源稀少</td></tr><tr><td>以下哪个测试工具是使用最广泛的性能测试产品工具。</td><td><strong>A.Load Runner</strong></td><td>B.Selenium</td><td>C.JMeter</td><td>D.Quick Test  Professional</td></tr><tr><td>CM6</td><td></td><td></td><td></td><td></td></tr><tr><td>下面哪项不是软件度量的目标（）</td><td>A.用数据指标表明验收标准</td><td>B.分配资源时进行量化均衡</td><td>C.便于对软件质量进行评价</td><td><strong>D.发现软件中的缺陷数量</strong></td></tr><tr><td>下面哪项不是软件度量的用途?</td><td>A.衡量软件过程质量</td><td>B.项目度量</td><td><strong>C.开发人员成效度量</strong></td><td>D.产品质量度量</td></tr><tr><td>下面项类质量数据不能用于<strong>评估软件稳定性?</strong></td><td><strong>A.正确性</strong></td><td>B.可靠性</td><td>C.可维护性</td><td>D.可用性</td></tr><tr><td>下面哪项活动是软件度量的阶段活动?</td><td>A.识别目标</td><td>B.定义度量过程</td><td>C.数据分析与反馈</td><td><strong>D.以上都是</strong></td></tr><tr><td>软件度量的维度是下面哪项？</td><td>A.项目度量</td><td>B.产品度量</td><td>C.过程度量</td><td><strong>D.以上都是</strong></td></tr><tr><td>下面哪项工作需要SQA人员来完成？</td><td>A.需求评审</td><td><strong>B.过程评审</strong></td><td>C.设计评审</td><td>D.系统测试</td></tr><tr><td>下面哪项工作需要SQA人员来完成？</td><td>A.制定SQA计划</td><td>B.审查软件过程</td><td>C.软件测试过程监督</td><td><strong>D.以上都是</strong></td></tr><tr><td>测试<strong>计划</strong>不包括下面哪项工作？</td><td>A.测试计划安排</td><td>B.测试风险识别</td><td><strong>C.测试流程审计</strong></td><td>D.测试资源安排</td></tr><tr><td>SQA在项目早期要根据项目计划制定与其对应的SQA计划</td><td>对</td><td></td><td></td><td></td></tr><tr><td>SQA是贯穿整个软件过程的第三方独立审查活动</td><td>对</td><td></td><td></td><td></td></tr></tbody></table><p><strong>1.针对电子科技大学信息门户的“密码找回”界面的邮箱输入域进行验证， 采用等价划分法设计相应的测试用例，包括尽量多的无效等价类。</strong></p><p>等价类划分</p><table><thead><tr><th align="center">有效等价类</th><th align="center">无效等价类</th></tr></thead><tbody><tr><td align="center">含有@符号  (1)</td><td align="center">不含@符号  (2)</td></tr><tr><td align="center">@后面的内容为std.uestc.edu.cn  (3)</td><td align="center">@后面的格式不是std.uestc.edu.cn AND@后面的格式不是uestc.edu.cn(5)</td></tr><tr><td align="center">@后面的内容为uestc.edu.cn(4)</td><td align="center"></td></tr><tr><td align="center">邮箱用户名由数字、字母或下划线组成(6)</td><td align="center">邮箱用户名含有除字母、数字、下划线以外的特殊字符(7)</td></tr><tr><td align="center">用户名必须由字母或数字开头(8)</td><td align="center">用户名不是由字母或数字开头(9)</td></tr></tbody></table><p>测试用例</p><table><thead><tr><th align="center">序号</th><th align="center">测试用例</th><th align="center">覆盖等价类</th><th align="center">输出</th></tr></thead><tbody><tr><td align="center">1</td><td align="center"><a href="mailto:zyh@uestc.edu.cn">zyh@uestc.edu.cn</a></td><td align="center">(1)(4)(6)(8)</td><td align="center">正确</td></tr><tr><td align="center">2</td><td align="center"><a href="mailto:zyh@std.uestc.edu.cn">zyh@std.uestc.edu.cn</a></td><td align="center">(1)(3)(6)(8)</td><td align="center">正确</td></tr><tr><td align="center">3</td><td align="center">zyhstd.uestc.edu.cn</td><td align="center">(2)(4)(6)(8)</td><td align="center">错误</td></tr><tr><td align="center">4</td><td align="center"><a href="mailto:zh@163.com">zh@163.com</a></td><td align="center">(1)(5)(6)(8)</td><td align="center">错误</td></tr><tr><td align="center">5</td><td align="center">zyh#@std.uestc.edu.cn</td><td align="center">(1)(3)(7)(8)</td><td align="center">错误</td></tr><tr><td align="center">6</td><td align="center"><a href="mailto:__yh@std.uestc.edu.cn">__yh@std.uestc.edu.cn</a></td><td align="center">(1)(3)(6)(9)</td><td align="center">错误</td></tr></tbody></table><p><strong>2.综合运用边界值方法和等价类方法，针对三角形问题设计相应的测试用例。假定输入三个整数（a、b、c）作为边，分别满足一般三角形、等腰三角形和等边三角形。</strong></p><p><strong>1）判断一般三角形的有效等价类是什么?</strong></p><p><strong>2）判断一般三角形的无效等价是什么?</strong></p><p><strong>3）判断等腰三角形的有效等价类是什么?</strong></p><p><strong>4）判断等腰三角形的无效等价类是什么?</strong></p><p><strong>5）判断等边三角形的有效等价类是什么?</strong></p><p><strong>6）判断等边三角形的无效等价类是什么?</strong></p><p>等价类划分</p><table><thead><tr><th align="center">输入条件</th><th align="center">有效等价类</th><th align="center">无效等价类</th></tr></thead><tbody><tr><td align="center">是否为三角形</td><td align="center">a&gt;0(1)</td><td align="center">a≤0(7)</td></tr><tr><td align="center"></td><td align="center">b&gt;0(2)</td><td align="center">b≤0(8)</td></tr><tr><td align="center"></td><td align="center">c&gt;0(3)</td><td align="center">c≤0(9)</td></tr><tr><td align="center"></td><td align="center">a+b&gt;c(4)</td><td align="center">a+b≤c(10)</td></tr><tr><td align="center"></td><td align="center">b+c&gt;a(5)</td><td align="center">b+c≤a(11)</td></tr><tr><td align="center"></td><td align="center">a+c&gt;b(6)</td><td align="center">a+c≤b(12)</td></tr><tr><td align="center">是否为等腰三角形</td><td align="center">a = b(13)</td><td align="center">(a≠b)and(b≠c)and(c≠a) (16)</td></tr><tr><td align="center"></td><td align="center">b = c(14)</td><td align="center"></td></tr><tr><td align="center"></td><td align="center">c = a(15)</td><td align="center"></td></tr><tr><td align="center">是否为等边三角形</td><td align="center">(a=b)and(b=c) (17)</td><td align="center">a≠b(18)</td></tr><tr><td align="center"></td><td align="center"></td><td align="center">a≠c(19)</td></tr><tr><td align="center"></td><td align="center"></td><td align="center">b≠c(20)</td></tr></tbody></table><p>测试用例设计</p><table><thead><tr><th align="center">序号</th><th align="center">(a,b,c)</th><th align="center">覆盖等价类</th><th align="center">输出</th></tr></thead><tbody><tr><td align="center">1</td><td align="center">(3,4,5)</td><td align="center">(1)(2)(3)(4)(5)(6)</td><td align="center">一般三角形</td></tr><tr><td align="center">2</td><td align="center">(0,1,2)</td><td align="center">(7)</td><td align="center">不能构成三角形</td></tr><tr><td align="center">3</td><td align="center">(1,0,2)</td><td align="center">(8)</td><td align="center">不能构成三角形</td></tr><tr><td align="center">4</td><td align="center">(1,2,0)</td><td align="center">(9)</td><td align="center">不能构成三角形</td></tr><tr><td align="center">5</td><td align="center">(1,2,3)</td><td align="center">(10)</td><td align="center">不能构成三角形</td></tr><tr><td align="center">6</td><td align="center">(1,3,2)</td><td align="center">(12)</td><td align="center">不能构成三角形</td></tr><tr><td align="center">7</td><td align="center">(3,1,2)</td><td align="center">(11)</td><td align="center">不能构成三角形</td></tr><tr><td align="center">8</td><td align="center">(2,2,1)</td><td align="center">(1)(2)(3)(4)(5)(6)(13)</td><td align="center">等腰三角形</td></tr><tr><td align="center">9</td><td align="center">(1,2,2)</td><td align="center">(1)(2)(3)(4)(5)(6)(14)</td><td align="center">等腰三角形</td></tr><tr><td align="center">10</td><td align="center">(2,1,2)</td><td align="center">(1)(2)(3)(4)(5)(6)(15)</td><td align="center">等腰三角形</td></tr><tr><td align="center">11</td><td align="center">(3,4,5)</td><td align="center">(1)(2)(3)(4)(5)(6)(16)</td><td align="center">非等腰三角形</td></tr><tr><td align="center">12</td><td align="center">(1,1,1)</td><td align="center">(1)(2)(3)(4)(5)(6)(17)</td><td align="center">等边三角形</td></tr><tr><td align="center">13</td><td align="center">(2,2,1)</td><td align="center">(1)(2)(3)(4)(5)(6)(19)(20)(13)</td><td align="center">非等边三角形</td></tr><tr><td align="center">14</td><td align="center">(1,2,2)</td><td align="center">(1)(2)(3)(4)(5)(6)(18)(19)(16)</td><td align="center">非等边三角形</td></tr><tr><td align="center">15</td><td align="center">(2,1,2)</td><td align="center">(1)(2)(3)(4)(5)(6)(15)(18)(20)</td><td align="center">非等边三角形</td></tr></tbody></table><p>(1) 、(1)(2)(3)(4)(5)(6)</p><p>(2)、(7)(8)(9)(10)(11)(12)</p><p>(3)、(1)(2)(3)(4)(5)(6)(13)(14)(15)</p><p>(4)、(7)(8)(9)(10)(11)(12)(16)</p><p>(5)、(1)(2)(3)(4)(5)(6)(17)</p><p>(6)、(7)(8)(9)(10)(11)(12)(18)(19)(20)</p><p><strong>3.系统的年、月、日数据由Y、M、D单元来存储相应值，若要测试NextData（Y,M,D）函数，采用判定表方法设计相应的测试用例。</strong>  </p><p>M1={m=1,3,5,7,8,10}     M2={m=4,6,9,11}     M3={m=12}     M4={m=2}</p><p>D1={1≤D≤27}    D2={D=28}    D3={D=29}    D4={D=30}    D5={D=31}</p><p>Y1={Y是闰年}    Y2={Y是平年}</p><table><thead><tr><th align="center"></th><th align="center"></th><th align="center">1</th><th align="center">2</th><th align="center">3</th><th align="center">4</th><th align="center">5</th><th align="center">6</th><th align="center">7</th><th align="center">8</th></tr></thead><tbody><tr><td align="center">条件</td><td align="center">Y</td><td align="center">Y1,Y2</td><td align="center">Y1,Y2</td><td align="center">Y1,Y2</td><td align="center">Y1,Y2</td><td align="center">Y1,Y2</td><td align="center">Y1,Y2</td><td align="center">Y1,Y2</td><td align="center">Y1,Y2</td></tr><tr><td align="center"></td><td align="center">M</td><td align="center">M2</td><td align="center">M2</td><td align="center">M2</td><td align="center">M1</td><td align="center">M1</td><td align="center">M3</td><td align="center">M3</td><td align="center">M4</td></tr><tr><td align="center"></td><td align="center">D</td><td align="center">D1,D2,D3</td><td align="center">D4</td><td align="center">D5</td><td align="center">D1,D2,D3,D4</td><td align="center">D5</td><td align="center">D1,D2,D3,D4</td><td align="center">D5</td><td align="center">D1</td></tr><tr><td align="center">动作</td><td align="center">不可能</td><td align="center">0</td><td align="center">0</td><td align="center">1</td><td align="center">0</td><td align="center">0</td><td align="center">0</td><td align="center">0</td><td align="center">0</td></tr><tr><td align="center"></td><td align="center">D+1</td><td align="center">1</td><td align="center">0</td><td align="center">0</td><td align="center">1</td><td align="center">0</td><td align="center">1</td><td align="center">0</td><td align="center">1</td></tr><tr><td align="center"></td><td align="center">D复位</td><td align="center">0</td><td align="center">1</td><td align="center">0</td><td align="center">0</td><td align="center">1</td><td align="center">0</td><td align="center">1</td><td align="center">0</td></tr><tr><td align="center"></td><td align="center">M+1</td><td align="center">0</td><td align="center">1</td><td align="center">0</td><td align="center">0</td><td align="center">1</td><td align="center">0</td><td align="center">0</td><td align="center">0</td></tr><tr><td align="center"></td><td align="center">M复位</td><td align="center">0</td><td align="center">0</td><td align="center">0</td><td align="center">0</td><td align="center">0</td><td align="center">0</td><td align="center">1</td><td align="center">0</td></tr><tr><td align="center"></td><td align="center">Y+1</td><td align="center">0</td><td align="center">0</td><td align="center">0</td><td align="center">0</td><td align="center">0</td><td align="center">0</td><td align="center">1</td><td align="center">0</td></tr></tbody></table><p>续:</p><table><thead><tr><th align="center"></th><th align="center"></th><th align="center">9</th><th align="center">10</th><th align="center">11</th><th align="center">12</th><th align="center">13</th></tr></thead><tbody><tr><td align="center">条件</td><td align="center">Y</td><td align="center">Y1</td><td align="center">Y2</td><td align="center">Y1</td><td align="center">Y2</td><td align="center">Y1,Y2</td></tr><tr><td align="center"></td><td align="center">M</td><td align="center">M4</td><td align="center">M4</td><td align="center">M4</td><td align="center">M4</td><td align="center">M4</td></tr><tr><td align="center"></td><td align="center">D</td><td align="center">D2</td><td align="center">D2</td><td align="center">D3</td><td align="center">D3</td><td align="center">D4,D5</td></tr><tr><td align="center">动作</td><td align="center">不可能</td><td align="center">0</td><td align="center">0</td><td align="center">0</td><td align="center">1</td><td align="center">1</td></tr><tr><td align="center"></td><td align="center">D+1</td><td align="center">1</td><td align="center">0</td><td align="center">0</td><td align="center">0</td><td align="center">0</td></tr><tr><td align="center"></td><td align="center">D复位</td><td align="center">0</td><td align="center">1</td><td align="center">1</td><td align="center">0</td><td align="center">0</td></tr><tr><td align="center"></td><td align="center">M+1</td><td align="center">0</td><td align="center">1</td><td align="center">1</td><td align="center">0</td><td align="center">0</td></tr><tr><td align="center"></td><td align="center">M复位</td><td align="center">0</td><td align="center">0</td><td align="center">0</td><td align="center">0</td><td align="center">0</td></tr><tr><td align="center"></td><td align="center">Y+1</td><td align="center">0</td><td align="center">0</td><td align="center">0</td><td align="center">0</td><td align="center">0</td></tr></tbody></table><p>测试用例设计:</p><table><thead><tr><th align="center">序号</th><th align="center">(Y,M,D)</th><th align="center">预期输出</th></tr></thead><tbody><tr><td align="center">1</td><td align="center">(2022,3,11)</td><td align="center">2022年3月12日</td></tr><tr><td align="center">2</td><td align="center">(2022,4,30)</td><td align="center">2022年5月1日</td></tr><tr><td align="center">3</td><td align="center">(2022,4,31)</td><td align="center">不可能</td></tr><tr><td align="center">4</td><td align="center">(2022,1,20)</td><td align="center">2022年1月21日</td></tr><tr><td align="center">5</td><td align="center">(2022,1,31)</td><td align="center">2022年2月1日</td></tr><tr><td align="center">6</td><td align="center">(2022,12,18)</td><td align="center">2022年12月19日</td></tr><tr><td align="center">7</td><td align="center">(2022,12,31)</td><td align="center">2023年1月1日</td></tr><tr><td align="center">8</td><td align="center">(2022,2,2)</td><td align="center">2022年2月3日</td></tr><tr><td align="center">9</td><td align="center">(2024,2,28)</td><td align="center">2024年2月29日</td></tr><tr><td align="center">10</td><td align="center">(2022,2,28)</td><td align="center">2022年3月1日</td></tr><tr><td align="center">11</td><td align="center">(2024,2,29)</td><td align="center">2024年3月1日</td></tr><tr><td align="center">12</td><td align="center">(2022,2,29)</td><td align="center">不可能</td></tr><tr><td align="center">13</td><td align="center">(2022,2,31)</td><td align="center">不可能</td></tr></tbody></table><p><strong>4.针对某机构人员管理的业务规则需求：</strong></p><p><strong>1）年薪制员工：严重过失，扣年终风险金的4%；过失，扣年终风险金的2%。</strong></p><p><strong>2）非年薪制员工：严重过失，扣当月薪资的8%；过失，扣当月薪资的4%。</strong></p><p><strong>请绘制出因果图和判定表，并给出相应的测试用例。</strong></p><p> C1:是年薪制员工  C2:严重过失  C3:是非年薪制员工 C4:过失</p><p>E1:扣年终风险金的4%  E2:扣年终风险金的2%  E3:扣当月薪资的8%  E4:扣当月薪资的4%</p><p>因果图:</p><p><img src="https://s2.loli.net/2022/05/24/NavRoVncTgGCOJs.png"></p><p>判定表:</p><table><thead><tr><th align="center">序号</th><th align="center"></th><th align="center">1</th><th align="center">2</th><th align="center">3</th><th align="center">4</th><th align="center">5</th><th align="center">6</th></tr></thead><tbody><tr><td align="center">原因</td><td align="center">C1</td><td align="center">1</td><td align="center">1</td><td align="center">0</td><td align="center">0</td><td align="center">1</td><td align="center">0</td></tr><tr><td align="center"></td><td align="center">C2</td><td align="center">1</td><td align="center">0</td><td align="center">1</td><td align="center">0</td><td align="center">0</td><td align="center">0</td></tr><tr><td align="center"></td><td align="center">C3</td><td align="center">0</td><td align="center">0</td><td align="center">1</td><td align="center">1</td><td align="center">0</td><td align="center">1</td></tr><tr><td align="center"></td><td align="center">C4</td><td align="center">0</td><td align="center">1</td><td align="center">0</td><td align="center">1</td><td align="center">0</td><td align="center">0</td></tr><tr><td align="center">结果</td><td align="center">E1</td><td align="center">1</td><td align="center">0</td><td align="center">0</td><td align="center">0</td><td align="center">0</td><td align="center">0</td></tr><tr><td align="center"></td><td align="center">E2</td><td align="center">0</td><td align="center">1</td><td align="center">0</td><td align="center">0</td><td align="center">0</td><td align="center">0</td></tr><tr><td align="center"></td><td align="center">E3</td><td align="center">0</td><td align="center">0</td><td align="center">1</td><td align="center">0</td><td align="center">0</td><td align="center">0</td></tr><tr><td align="center"></td><td align="center">E4</td><td align="center">0</td><td align="center">0</td><td align="center">0</td><td align="center">1</td><td align="center">0</td><td align="center">0</td></tr></tbody></table><p>测试用例:</p><table><thead><tr><th align="center">序号</th><th align="center">输入</th><th align="center">输出</th></tr></thead><tbody><tr><td align="center">1</td><td align="center">年薪制员工,严重过失</td><td align="center">扣年终风险金的4%</td></tr><tr><td align="center">2</td><td align="center">年薪制员工,过失</td><td align="center">扣年终风险金的2%</td></tr><tr><td align="center">3</td><td align="center">非年薪制员工,严重过失</td><td align="center">扣当月薪资的8%</td></tr><tr><td align="center">4</td><td align="center">非年薪制员工,过失</td><td align="center">扣当月薪资的4%</td></tr><tr><td align="center">5</td><td align="center">年薪制员工,无过失</td><td align="center">不扣</td></tr><tr><td align="center">6</td><td align="center">非年薪制员工,无过失</td><td align="center">不扣</td></tr></tbody></table><p><strong>5.测试一个登录页面在不同浏览器和语言下的功能正确性，其输入条件如下:</strong></p><p><strong>1）输入项（账号、密码）</strong></p><p><strong>2）浏览器（IE、chrome、FireFox、360）</strong></p><p><strong>3）语言（中文、英文）</strong></p><p><strong>请问进行完整组合的兼容性测试需要多少个测试用例？采用成对组合的兼容性测试需要多少个测试用例？给出成对组合测试用例表。</strong></p><p>答:完整组合的兼容性测试需要 32个测试用例</p><p>​     采用成对组合的兼容性测试需要10个测试用例</p><table><thead><tr><th align="center">序号</th><th align="center">账号</th><th align="center">密码</th><th align="center">浏览器</th><th align="center">语言</th></tr></thead><tbody><tr><td align="center">1</td><td align="center">填值</td><td align="center">填值</td><td align="center">IE</td><td align="center">中文</td></tr><tr><td align="center">2</td><td align="center">填值</td><td align="center">空值</td><td align="center">chrome</td><td align="center">英文</td></tr><tr><td align="center">3</td><td align="center">填值</td><td align="center">填值</td><td align="center">FireFox</td><td align="center">中文</td></tr><tr><td align="center">4</td><td align="center">填值</td><td align="center">空值</td><td align="center">360</td><td align="center">英文</td></tr><tr><td align="center">5</td><td align="center">空值</td><td align="center">空值</td><td align="center">IE</td><td align="center">英文</td></tr><tr><td align="center">6</td><td align="center">空值</td><td align="center">填值</td><td align="center">chrome</td><td align="center">中文</td></tr><tr><td align="center">7</td><td align="center">空值</td><td align="center">空值</td><td align="center">FireFox</td><td align="center">英文</td></tr><tr><td align="center">8</td><td align="center">空值</td><td align="center">填值</td><td align="center">360</td><td align="center">中文</td></tr><tr><td align="center">9</td><td align="center">空值</td><td align="center">填值</td><td align="center">IE</td><td align="center">英文</td></tr><tr><td align="center">10</td><td align="center">空值</td><td align="center">空值</td><td align="center">chrome</td><td align="center">中文</td></tr><tr><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr></tbody></table>]]></content>
      
      
      
        <tags>
            
            <tag> 软件测试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机操作系统(二)</title>
      <link href="posts/8c2e937.html"/>
      <url>posts/8c2e937.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="进程的描述与控制"><a href="#进程的描述与控制" class="headerlink" title="进程的描述与控制"></a>进程的描述与控制</h1><h2 id="前趋图与程序执行"><a href="#前趋图与程序执行" class="headerlink" title="前趋图与程序执行"></a>前趋图与程序执行</h2><p><strong>前趋图</strong>用于描述程序执行的先后顺序。</p><p><img src="https://s2.loli.net/2022/01/20/QpgWzeNRfnPk8xb.png" alt="image.png"></p><p>前趋图中的每个结点可用来表示一个进程或程序段，乃至一条语句，结点间的有向边则表示两个结点之间存在的偏序或前趋关系。</p><p><strong>前趋图中不允许有循环</strong></p><p>合理前趋图：</p><p><img src="https://s2.loli.net/2022/01/20/a3AeMy2VztIjiXc.png" alt="image.png"></p><p>如上图，存在以下前趋关系：</p><p>P1→P2,P1→P3,P1→P4,P2→P5,P3→P5,P4→P6,P4→P7,P5→P8,P6→P8,P7→P9,P8→P9</p><p>或表示为：</p><p>P={P1,P2,P3,P4,P5,P6,P7,P8,P9}</p><p>  ={(P1,P2),(P1,P3),(P1,P4),(P2,P5),(P3,P5),(P4,P6),(P4,P7),(P5,P8),(P6,P8),(P7,P9),(P8,P9)}</p><p>不正确的前趋图（具有循环）：</p><p><img src="https://s2.loli.net/2022/01/20/Y6y1CPhTtwJfv4O.png" alt="1642682545729.png"></p><p>S2→S3，S3→S2，显然是无法实现的。</p><h4 id="程序顺序执行"><a href="#程序顺序执行" class="headerlink" title="程序顺序执行"></a>程序顺序执行</h4><p><img src="https://s2.loli.net/2022/01/20/KzslmiI6Zw1Q4j2.png" alt="image.png"></p><p><strong>程序顺序执行时的特征：</strong></p><ol><li><p>顺序性</p><p>指处理机严格地按照程序所规定的顺序执行，即每一操作必须在下一个操作开始之前结束；</p></li><li><p>封闭性</p><p>指程序在封闭的环境下运行，即程序运行时独占全机资源，资源的状态（除初始状态之外）只有本程序才能改变它，程序一旦开始执行，其执行结果不受外界因素影响；</p></li><li><p>可再现性</p><p>指只要程序执行时的环境和初始条件相同，当程序重复执行时，不论它是从头到尾不停顿地执行，还是“停停走走”地执行，都可获得相同的结果。</p></li></ol><h4 id="程序并发执行"><a href="#程序并发执行" class="headerlink" title="程序并发执行"></a>程序并发执行</h4><p>以打印为例：由输入程序（I）、计算程序（C）、打印程序（P）组成，单个打印作业存在Ii→Ci→Pi这样的顺序执行的前趋关系，但对于多个打印作业如果全部按照顺序方式执行依次输入，则对于CPU利用率较小，故采用并发方式执行：</p><p><img src="https://s2.loli.net/2022/01/20/BX7bMSaikKtDPVW.png" alt="image.png"></p><p>由图可以看出Pi-1和Ci以及Ii+1之间不存在前趋关系，可以并发执行。</p><p><strong>程序并发执行时的特征</strong></p><ol><li><p>间断性</p><p>程序在并发执行时，由于它们共享系统资源，以及为完成同一项任务而相互合作，致使在这些并发程序之间形成了相互制约的关系。</p></li><li><p>失去封闭性</p><p>资源共享</p></li><li><p>不可再现性</p><p>由于失去封闭性，导致其失去了不可再现性，即使执行的环境和初始条件相同也不一定得到相同结果。与执行速度有关。</p></li></ol><h2 id="进程的描述"><a href="#进程的描述" class="headerlink" title="进程的描述"></a>进程的描述</h2><blockquote><p>①进程是程序的一次执行；</p><p>②进程是一个程序及其数据在处理机上顺序执行时所发生的活动；</p><p>③进程是具有独立功能的程序在一个数据集合上运行的过程，它是系统进行资源分配和调度的一个独立单位。</p><p>进程是进程实体的运行过程，是系统进行资源分配和调度的一个独立单位。</p></blockquote><p>为什么要引入进程这个概念？所有事物的发展都是从简单到复杂，而在最初，程序执行往往是连续的、封闭的、可再现的，也就是说顺序执行，这也是通常的程序具有的一般性质，那么如何使程序能够并发执行，并且对这种并发加以描述和控制呢？就引入进程这一概念，所以进程往往具有程序并发执行的一些特征。</p><p><strong>PCB</strong></p><blockquote><p>为了使参与并发执行的每个程序（含数据）都能独立运行，在操作系统中必须为之配置一个专门的数据结构，称为进程控制块（PCB）</p></blockquote><p>由<strong>程序段</strong>、<strong>相关的数据段</strong>和<strong>PCB</strong>三部分就构成了进程实体，一般情况下简称为进程。</p><p>创建进程：创建进程实体中的PCB</p><p>撤销进程：撤销进程的PCB</p><p><strong>进程的特征</strong></p><table><thead><tr><th align="center">进程</th><th align="center">程序</th></tr></thead><tbody><tr><td align="center">①动态性  进程的实质是进程实体的执行过程，具有一定的生命期，创建（产生）—调度（执行）—撤销（消亡）</td><td align="center">静态的  只是一组有序指令的集合，本身不具有活动的含义</td></tr><tr><td align="center">②并发性  多个进程实体同存在于内存之中，且能在同一段时间内同时运行（也是引入进程的目的所在）</td><td align="center">程序（没有建立PCB）是不能参与并发执行的</td></tr><tr><td align="center">③独立性  进程实体是一个能独立运行、独立获得资源和独立接受调度的基本单位</td><td align="center">凡未建立PCB的程序都不能作为一个独立的单位参与运行</td></tr><tr><td align="center">④异步性  进程按各自独立的、不可预知的速度向前推进</td><td align="center">传统意义上的程序若参与并发执行，会产生其结果的不可再现性。</td></tr></tbody></table><p>备注：针对④，为使进程在并发运行时虽具有异步性，但仍能保证进程并发执行的结果是可再现的，在OS中引进了进程的概念，并配置相应的进程同步机制。</p><h3 id="进程的状态及转换"><a href="#进程的状态及转换" class="headerlink" title="进程的状态及转换"></a>进程的状态及转换</h3><p>一般而言，进程应至少处于就绪、执行、阻塞三种基本状态之一。</p><p><img src="https://s2.loli.net/2022/01/22/IJtKW6HGbYCe7sM.png" alt="image.png"></p><h4 id="三种基本状态以及转换"><a href="#三种基本状态以及转换" class="headerlink" title="三种基本状态以及转换"></a>三种基本状态以及转换</h4><p>（1）就绪状态：除了CPU以外的全部资源都已经准备好。如果系统中有多个处于就绪状态的进程，通常将它们按照一定的策略（如优先级策略）排成<strong>就绪队列</strong>。</p><p>（2）执行状态：已获得CPU，正在执行的状态。   通常单处理机中只有一个进程处于执行状态；多处理机中可有多个进程处于执行状态。</p><p>（3）阻塞状态：正在执行的进程由于发生某事件（如I/O请求、申请缓冲区失败等）暂时无法继续执行的状态，亦即进程的执行受到阻塞。      此时引起进程调度，OS将处理机分配给另一个就绪进程，而让受阻进程处于暂停状态。     阻塞队列：通常根据阻塞原因不同，设置多个阻塞队列。</p><p>就绪状态→<strong>调度程序为之分配处理机</strong>→执行状态→<strong>分配给它的时间片已完成被剥夺处理机暂停执行</strong>→就绪状态</p><p>执行状态→<strong>发生某事件使进程受阻，使之无法继续执行</strong>→阻塞状态</p><p>某事件举例：进程访问某临界资源，而该资源正被其他进程访问。</p><h4 id="创建进程以及创建状态"><a href="#创建进程以及创建状态" class="headerlink" title="创建进程以及创建状态"></a>创建进程以及创建状态</h4><p><img src="https://s2.loli.net/2022/01/22/F2boTfNzdkX8EwC.png" alt="image.png"></p><h4 id="进程的终止与终止状态"><a href="#进程的终止与终止状态" class="headerlink" title="进程的终止与终止状态"></a>进程的终止与终止状态</h4><p>进程的终止需要两个步骤：等待操作系统进行善后处理（其他进程对其信息进行提取【保留记录】）；将其PCB清零，并将PCB空间返还系统。</p><p>终止条件：</p><ul><li><p>进程到达了自然临界点</p></li><li><p>出现了无法克服的错误</p></li><li><p>被操作系统所终结</p></li><li><p>被其他有终止权的进程终结</p><p>（详见本篇进程控制部分）</p></li></ul><p>被终止后的进程以后不再执行，但在操作系统中依然保留一个记录，其中保存状态码和一些及时统计数据，供其它进程收集。</p><h4 id="挂起操作和进程状态转换"><a href="#挂起操作和进程状态转换" class="headerlink" title="挂起操作和进程状态转换"></a>挂起操作和进程状态转换</h4><blockquote><p>挂起：意味着此时进程处于静止状态——&gt;不能被调度/暂停执行</p><p>激活：与挂起操作相对应</p></blockquote><p>由此，产生了活动就绪、静止就绪；活动阻塞、静止阻塞</p><p><strong>引入挂起操作的原因</strong></p><ol><li><p>终端用户的需要</p></li><li><p>父进程请求</p></li><li><p>负荷调节的需要</p></li><li><p>操作系统的需要</p><p>总的来讲，是为了排查或者避免一些运行中的问题、协调进程活动。</p></li></ol><p><img src="https://s2.loli.net/2022/01/22/uLmUkHFSz47wCYg.png" alt="image.png"></p><p>就绪：进程在内存，准备执行</p><p>阻塞：进程在内存，等待执行</p><p>就绪挂起：进程在外存，暂时不调度</p><p>阻塞挂起：进程在外存</p><h3 id="进程管理中的数据结构——进程表PCB"><a href="#进程管理中的数据结构——进程表PCB" class="headerlink" title="进程管理中的数据结构——进程表PCB"></a>进程管理中的数据结构——进程表PCB</h3><blockquote><p><strong>PCB</strong>的作用：是一个在多道程序环境下不能独立运行的程序（含数据）成为一个能独立运行的基本单位，一个能与其他进程并发执行的进程。</p><p>（1）作为独立运行基本单位的标志</p><p>（2）能实现间断性运行方式</p><p>（3）提供进程管理所需要的信息</p><p>（4）提供进程调度所需要的信息</p><p>（5）实现与其他进程的同步与通信</p></blockquote><p><img src="https://s2.loli.net/2022/01/22/TBgY1oJNrkx7dKn.png" alt="image.png"></p><h4 id="进程控制块的组织方式"><a href="#进程控制块的组织方式" class="headerlink" title="进程控制块的组织方式"></a>进程控制块的组织方式</h4><blockquote><p>在一个系统中，通常可以有数十个、数百个乃至数千个PCB。为了能对它们加以有效的管理，应采用适当的方式对其进行组织。</p></blockquote><p>（1）线性方式</p><p>将系统中所有PCB组织在一张表中，将该表的首址存放在内存的一个专用区域中。</p><p><img src="https://s2.loli.net/2022/01/22/2UDdSTWxhLY9Qjl.png" alt="image.png"></p><p>优点：简单、开销小</p><p>缺点：每次查找时都需要扫描整张表，效率较低</p><p>适用于进程数目不多的系统</p><p>（2）链接方式</p><p>将具有相同状态进程的PCB分别通过PCB中的链接字链接成一个队列。</p><p><img src="https://img-blog.csdnimg.cn/20200926222207588.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NTU2NTk5,size_16,color_FFFFFF,t_70#pic_center" alt="image.png"></p><p>对就绪队列而言，往往按进程的优先级将PCB从高到低进行排列，将优先级高的进程PCB排在队列的前面。</p><p>（3）索引方式</p><p>系统根据所有进程状态不同，建立几张索引表，并把个索引表在内存的首地址记录在内存的一些专用单元中。在每个索引表的表目中，记录具有相应状态的某个PCB在PCB表中的地址。</p><p><img src="https://img-blog.csdnimg.cn/2020092622230441.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NTU2NTk5,size_16,color_FFFFFF,t_70#pic_center" alt="image.png"></p><h2 id="进程控制"><a href="#进程控制" class="headerlink" title="进程控制"></a>进程控制</h2><h4 id="操作系统内核"><a href="#操作系统内核" class="headerlink" title="操作系统内核"></a>操作系统内核</h4><blockquote><p>现代操作系统一般将OS划分为若干层次，再将OS的不同功能分别设置在不同的层次中。通常将一些<strong>与硬件紧密相关的模块</strong>（如中断处理程序等）、<strong>各种常用设备的驱动程序</strong>、<strong>运行频率较高的程序</strong>（如时钟管理、进程调度和许多模块公用的一些基本操作），都安排在紧靠硬件的软件层次中，将它们常驻内存，即通常被称为的OS内核。</p></blockquote><p>目的：</p><p>便于对这些软件进行保护，防止遭受其他应用程序的破坏；</p><p>提高OS的运行效率。</p><p>功能：</p><ol><li><p>支撑功能</p><p>提供给OS其他众多模块所需要的一些基本功能，以便支撑这些模块工作。</p><p>（1）中断处理 内核最基本的功能</p><p>（2）时钟管理</p><p>（3）原语操作  所谓原语，就是由若干条指令组成的，用于完成一定功能的一个过程。</p><p>与一般过程的区别：原语为“原子操作”，一个操作中所有动作要么全做，要么不做，是一个不可分割的基本单位。<strong>因此，原语在执行过程中不允许被中断</strong>。</p></li><li><p>资源管理功能</p><p>（1）进程管理</p><p>（2）存储器管理</p><p>（3）设备管理</p></li></ol><h4 id="进程的创建"><a href="#进程的创建" class="headerlink" title="进程的创建"></a>进程的创建</h4><p><strong>进程的层次结构</strong></p><ul><li>父进程与子进程：把创建进程的进程称为父进程，把被创建的进程称为子进程，子进程可以继续创建更多的进程。</li><li>进程间的继承关系：子进程可以继承父进程所拥有的资源（父进程打开的文件、分配到的缓冲区等）子进程被撤销时，应将其从父进程那里获得的资源归还给父进程；在撤销父进程时，也必须同时撤销其所有的子进程。进程不能拒绝其子进程的继承权。</li><li>Windows 句柄：不存在任何进程层次的概念，所有进程具有同等地位。如果一个进程创建另外的进程时获得一个句柄，其作用相当于一个令牌，可以用来控制被创建的进程。但是，<strong>这个句柄是可以进行传递的</strong>。获得句柄的进程就拥有了控制其他进程的权力。</li></ul><p><strong>进程图</strong></p><p>（类似树）结点为进程。</p><p><strong>引起创建进程的事件</strong></p><p>（1）用户登录</p><p>（2）作业调度</p><p>（3）提供服务</p><p>（4）应用请求</p><p><strong>进程的创建</strong></p><p>（1）申请空白PCB</p><p>（2）为新进程分配其运行所需的资源，包括各种物理和逻辑资源</p><p>（3）初始化进程控制块</p><p>​        ①初始化标识信息（系统分配的标识符和父进程标识符）</p><p>​        ②初始化处理机状态信息，使程序计数器指向程序的入口地址，使栈指针指向栈顶</p><p>​        ③初始化处理机控制信息，（状态：就绪/精致就绪；优先级）</p><p>（4）插入队列</p><h4 id="进程的终止"><a href="#进程的终止" class="headerlink" title="进程的终止"></a>进程的终止</h4><p><strong>引起进程终止的事件</strong></p><p>（1）正常结束</p><p>（2）异常结束</p><p>​        ①越界错 程序访问的存储区越出该进程区域</p><p>​        ②保护错 进程试图去访问一个不允许访问的资源或文件或以不适当的形式进行访问</p><p>​        ③非法指令 程序试图去执行一条不存在的指令</p><p>​        ④特权指令错 用户试图去执行一条只允许OS执行的指令</p><p>​        ⑤运行超时</p><p>​        ⑥等待超时</p><p>​        ⑦算术运算错</p><p>​        ⑧I/O故障</p><p><strong>进程的终止过程</strong></p><p>（1）根据标识符，读出该进程状态</p><p>（2）终止该进程，置调度标志为真</p><p>（3）终止子进程</p><p>（4）资源归还父进程</p><p>（5）移出队列，等待其他进程搜集信息</p><h4 id="进程的阻塞与唤醒"><a href="#进程的阻塞与唤醒" class="headerlink" title="进程的阻塞与唤醒"></a>进程的阻塞与唤醒</h4><p>阻塞原语：block</p><p>唤醒原语：wakeup   </p><p><strong>block原语和wakeup原语必须成对使用</strong></p><p>挂起原语：suspend</p><p>激活原语：active</p><p><strong>引起进程阻塞或唤醒的事件</strong></p><ol><li>向系统请求共享资源失败</li><li>等待某种操作完成</li><li>新数据尚未到达</li><li>等待新任务的到达</li></ol><p><strong>进程阻塞的过程</strong></p><p><strong><em>阻塞是进程自身的一种主动行为</em></strong>。正在执行的进程，若发生上述事件，<strong>进程</strong>便通过调用阻塞原语block将自己阻塞。</p><p>状态设置——插入队列——重新调度</p><p><strong>进程唤醒的过程</strong></p><p>调用唤醒原语wakeup</p><p>移出队列——状态设置——插入队列</p><h2 id="进程同步"><a href="#进程同步" class="headerlink" title="进程同步"></a>进程同步</h2><h3 id="进程同步的基本概念"><a href="#进程同步的基本概念" class="headerlink" title="进程同步的基本概念"></a>进程同步的基本概念</h3><p>我们还记得多道批处理时是不可再现的，这对我们检查、定位、修正异常带来了麻烦，进程和进程同步机制就是为了使多道批处理具有可再现性。</p><p>进程同步机制的主要任务，是对多个相关进程在执行次序上进行协调，使并发执行的诸进程之间能按照一定的规则（或时序）共享系统资源，并能很好的相互合作，从而使程序的执行具有可再现性。</p><p>1）间接相互制约  由于共享系统资源形成的相互制约关系</p><p>2）直接相互制约  未完成某任务而建立的多个进程，源于彼此间相互合作的制约关系。</p><p><strong>临界资源</strong>  采取互斥方式，实现对这类资源的共享</p><p>访问临界资源的代码段称为<strong>临界区</strong>。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>操作系统学习笔记(一)</title>
      <link href="posts/392e0872.html"/>
      <url>posts/392e0872.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="计算机操作系统-一"><a href="#计算机操作系统-一" class="headerlink" title="计算机操作系统(一)"></a>计算机操作系统(一)</h1><blockquote><p>操作系统是配置在计算机硬件上的第一层软件,是对硬件系统的首次扩充,其主要作用是管理好这些设备,提高它们的利用率和系统的吞吐量,并为用户和应用程序提供一个简单的接口,便于用户使用。</p></blockquote><h2 id="操作系统的目标、作用及发展过程"><a href="#操作系统的目标、作用及发展过程" class="headerlink" title="操作系统的目标、作用及发展过程"></a>操作系统的目标、作用及发展过程</h2><h3 id="操作系统的目标"><a href="#操作系统的目标" class="headerlink" title="操作系统的目标"></a>操作系统的目标</h3><ul><li><p><strong>方便性</strong></p><p>裸机使用→机器语言</p><p>配置OS→高级语言编写的程序或OS提供的命令→方便用户、易学易用</p></li><li><p>有效性</p><p>提高系统资源的利用率</p><p>提高系统的吞吐量</p></li><li><p><strong>可扩充性</strong></p><p>为适应计算机硬件、体系结构以及计算机应用发展的要求。</p><p>无结构→模块化结构→层次化结构→微内核结构</p></li><li><p>开放性</p><p>硬件与软件的兼容性</p><p>系统能遵循世界标准规范→统一的开放环境以实现应用的可移植性与互操作性</p><p>不同设备间可以通过网络集成，正确有效的协同工作</p></li></ul><h3 id="操作系统的作用"><a href="#操作系统的作用" class="headerlink" title="操作系统的作用"></a>操作系统的作用</h3><ol><li><p>作为用户与计算机硬件系统之间的接口；</p><p>（1）命令方式</p><p>（2）系统调用方式</p><p>（3）图标—窗口方式</p></li><li><p>作为计算机系统资源的管理者；</p><p><strong>计算机系统资源（四类</strong>）：处理机、存储器、I/O设备、文件（数据和程序）</p></li><li><p>实现了对计算机资源的抽象；</p></li></ol><h3 id="操作系统的发展过程"><a href="#操作系统的发展过程" class="headerlink" title="操作系统的发展过程"></a>操作系统的发展过程</h3><p>人工操作→单道批处理→多道批处理→分时系统→实时系统（优缺点）</p><h2 id="操作系统的基本特性"><a href="#操作系统的基本特性" class="headerlink" title="操作系统的基本特性"></a>操作系统的基本特性</h2><ol><li><p>并发</p><blockquote><p><strong>·</strong> <strong>并行与并发</strong></p></blockquote><blockquote><p><strong>并行性</strong>：两个或多个事件在同一**<em>时刻**</em>发生。</p><p><strong>并发性</strong>：两个或多个事件在同一**<em>时间间隔**</em>内发生。</p></blockquote><p>多道程序环境下：宏观上有多个程序在同时运行，但在单处理机系统中，每一时刻仅能有一道程序执行→微观上为分时交替进行→*<strong>并发**<em>。但是如果有多个处理机，这些可以并发执行的程序可以分配给不同处理机执行→</em></strong>并行***，实现微观意义上的同时进行。</p><blockquote><p><strong>·</strong> 进程与线程</p></blockquote><p>未引入进程：计算程序与I/O程序（CPU空闲）间顺序执行。对计算程序和I/O程序分别设立进程：可以并发执行。</p><p>引入进程：程序为静态的。进程为程序的执行→提高系统资源利用率，增加系统的吞吐量。</p><p>引入线程：进程的更小的可执行单位，一个进程可包含若干个进程。</p></li><li><p>共享</p><p>一般情况下共享与操作系统环境下的共享其含义并不相同：前者未限定借阅者必须在同一时间或间隔和同一地点进行共享；而在OS环境下的共享是指系统中的资源可供内存中多个并发执行的进程(线程)共同使用。 这里在<strong>宏观上</strong>既限定了时间（进程在内存期间内），也限定了地点（内存）。</p><p>由于资源属性的不同，进程对资源共享的方式也不同，目前主要有以下两种资源共享方式：<br><strong>互斥共享方式</strong><br>系统中的某些资源，如打印机、磁带机，虽然它们可以提供给多个进程(线程)使用，但为使所打印或记录的结果不致造成混淆，应规定在一段时间内只允许一个进程(线程)访问该资源，我们把这种资源共享方式称为互斥式共享。<br>临界资源或独占资源：一段时间内只允许一个进程访问的资源。计算机系统中的大多数物理设备，以及某些软件中所用的栈、变量和表格，都属于临界资源，它们要求被互斥地共享。<br><strong>同时访问方式</strong><br>允许在一段时间内由多个进程 “同时”对它们进行访问。这里所谓的“同时”往往是宏观上的，而在<strong>微观上</strong>，这些进程可能是交替地对该资源进行访问。<br>并发和共享是多用户(多任务)OS的两个最基本的特征。它们又是互为存在的条件。</p></li><li><p>虚拟</p><blockquote><p>在OS中,把通过某种技术将一个物理实体变为若干个逻辑上的对应物的功能称为”虚拟” 。前者为实体，后者则是虚的，是用户感觉上的东西。相应的，把用于实现虚拟的技术称为虚拟技术。</p></blockquote><p>“空分复用”或”时分复用”技术,将一条物理信道变为若干条逻辑信道.</p><p><em>时分复用技术</em></p><p>利用某<strong>设备</strong>为一用户服务的空闲时间，又转去为其他用户服务，使设备得到最充分的利用。</p><blockquote><p>⑴虚拟处理机技术：在虚拟处理机技术中，是通过多道程序设计技术，让多道程序并发执行的方法，来<strong>分时</strong>使用一台处理机的。（宏观）<br>⑵虚拟设备技术：将一台物理I/O设备虚拟为多台逻辑上的I/O设备，并允许每 个用户占用一台逻辑上的I/O设备，这样便可使原来仅允许在 一段时间内由一个用户访问的设备(即临界资源)，变为在一 段时间内允许多个用户同时访问的共享设备。</p><p>在操作系统中，虚拟的实现主要是通过分时复用的方法。显然，如果 n 是某物理设备所对应的虚拟的逻辑设备数，则虚拟设备的平均速度必然等于或低于物理设备速度的1 / n 。</p></blockquote><p><em>空分复用技术</em></p><p>利用<strong>存储器</strong>的空闲空间分区域存放和运行其他的多道程序，以此来提高内存的利用率。</p><p>类似分时复用技术，虚拟设备平均占用空间必然也低于或等于1/n。</p></li><li><p>异步</p><p>由于资源等因素的限制，使进程的执行通常都不是“一气呵成”， 而是以“停停走走”的方式运行。<br>内存中的每个进程在何时能获得处理机运行，何时又因提出某种资源请求而暂停，以及进程以怎样的速度向前推进，每道程序总共需多少时间才能完成，等等，都是不可预知的。由于各用户程序性能的不同，比如，有的侧重于计算而较少需要 I/O；而又有的程序其计算少而I/O多，这样，很可能是先进入内存的作业后完成；而后进入内存的作业先完成。或者说，<strong>进程是以人们不可预知的速度向前推进，此即进程的异步性</strong>。尽管如此，但只要运行环境相同，作业经多次运行，都会获得完全相同的结果。因此，异步运行方式是允许的，是操作系统的一个重要特征。</p></li></ol><h2 id="操作系统的主要功能"><a href="#操作系统的主要功能" class="headerlink" title="操作系统的主要功能"></a>操作系统的主要功能</h2><ol><li><p>处理机管理功能</p><ul><li>进程控制  为作业创建进程、撤销或终止已结束的进程、以及控制进程在运行中的状态转换。</li><li>进程同步  ①<strong>进程互斥方式</strong>②<strong>进程同步方式</strong></li><li>进程通信  实现相互合作进程之间的信息交换</li><li>调度          包括作业调度和进程调度两步：作业调度：将作业调入内存后，分别为他们建立进程；进程调度：按照一定的算法选出一个进程</li></ul></li><li><p>存储器管理功能</p><ul><li><p>内存分配  为每道程序分配内存空间；提高存储器的利用率；允许正在运行的程序申请附加的内存空间，以适应程序和数据动态增长的需要。</p></li><li><p>​     静态分配  作业的内存空间是在作业装入是确定的，装入后的运行期间不允许改作业申请新的内存空间或者改变内存空间（即不允许作业在内存中“移动”）。</p></li><li><p>​     动态分配  允许在运行期间申请新的内存空间和移动。</p></li><li><p>内存保护  确保每道用户程序都仅在自己的内存空间内运行，彼此互不干扰。</p><p>​                 绝不允许用户程序访问操作系统的程序和数据，也不允许用户程序转移到非共享的其它用户程序中去执行。</p></li><li><p>地址映射  逻辑地址与物理地址</p></li><li><p>内存扩充  逻辑上扩充内存容量（虚拟）</p></li></ul></li><li><p>设备管理功能</p><ul><li><p>缓冲管理  ①缓和I/O设备和CPU之间速度不匹配的矛盾，提高CPU利用率。提高系统的吞吐量。</p><p>​                 ②改善系统的性能</p></li><li><p>设备分配</p></li><li><p>设备处理</p></li></ul></li><li><p>文件管理功能</p><ul><li>缓冲管理</li><li>设备分配</li><li>设备处理</li></ul></li><li><p>操作系统与用户之间的接口</p><ul><li>用户接口</li><li>程序接口</li></ul></li><li><p>（现代）系统安全</p></li><li><p>（现代）网络的功能和服务</p></li><li><p>（现代）支持多媒体</p></li></ol><h2 id="操作系统结构设计"><a href="#操作系统结构设计" class="headerlink" title="操作系统结构设计"></a>操作系统结构设计</h2><h4 id="模块化结构设计"><a href="#模块化结构设计" class="headerlink" title="模块化结构设计"></a>模块化结构设计</h4><p><img src="https://s2.loli.net/2022/01/17/oyPSB4heOusbikn.png" alt="image.png"></p><p>模块独立性标准:内聚性,耦合度——高内聚，低耦合。</p><p>模块-接口法优点：</p><p>​    提高OS设计的正确性、可理解性和可维护性。</p><p>​    增强OS的可适应性。</p><p>​    加速OS的开发过程。</p><h4 id="分层式结构"><a href="#分层式结构" class="headerlink" title="分层式结构"></a>分层式结构</h4><ul><li>优点：<br>易保证系统的正确性<br>易拓充<br>易维护</li><li>缺点：<br>系统效率降低</li></ul><h4 id="客户-服务器模式"><a href="#客户-服务器模式" class="headerlink" title="客户/服务器模式"></a>客户/服务器模式</h4><h4 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h4><h4 id="微内核"><a href="#微内核" class="headerlink" title="微内核"></a>微内核</h4>]]></content>
      
      
      
        <tags>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>机器学习Day1</title>
      <link href="posts/8625e497.html"/>
      <url>posts/8625e497.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>[TOC]</p><h1 id="机器学习-Day-1"><a href="#机器学习-Day-1" class="headerlink" title="机器学习 Day.1"></a>机器学习 Day.1</h1><blockquote><p>一般地，令D = {x,x2….x.m}表示包含m个示例的数据集，每个示例由d个属性描述,则每个示例Xi= (xi1;xi2;……;xid) 是d维样本空间X中的一个向量, xi∈x,其中xij是xi在第j个属性上的取值(例如上述第3个西瓜在第2个属性上的值是“硬挺”), d称为样本xi的“维数”(dimensionality).</p></blockquote><h2 id="基础概念"><a href="#基础概念" class="headerlink" title="基础概念"></a>基础概念</h2><ul><li>（属性1 = 取值，属性2 = 取值，……，属性3=取值）——一个示例</li><li>{示例1，示例2，……，示例3}——数据集</li></ul><p>每条示例中所有的属性分别看作一根坐标轴张成==属性空间/样本空间==，则可以把一个示例称为==特征向量==</p><pre class="line-numbers language-mermaid" data-language="mermaid"><code class="language-mermaid">graph LRA[预测任务] --&gt;Z(监督学习)A --&gt;Y(无监督学习)Y--&gt;X(聚类)Z --&gt;B(离散型)  B --&gt; C(分类)    C --&gt;|仅涉及两个类别|F(二分类)    F --&gt;M(y = -1,+1)    C --&gt;|涉及多个类别|G(多分类)    G --&gt;L(y的绝对值&gt;2)  Z --&gt;D(连续型)  D --&gt;E(回归)    E --&gt;N(y=R)  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>泛化能力：学得模型适用于新样本的能力。</li><li>假设空间规模大小：搜索目标是找到能够将训练集中的瓜判断正确的假设。假设的表示一旦确定，假设空间及规模大小也就确定了：（属性1的表示个数<em>属性2的……</em>属性n的表示个数==+1==）</li></ul><p>注：在考虑取值的时候，要考虑==该属性不影响结果==（用通配符*表示）、==不存在要求结果==（输出结果为空）两种容易忽略的情况。</p><ul><li><p>版本空间：根据假设的表示得到假设空间，剔除与样本集中正例（某事发生）不一致的假设向量和与负例一致的假设向量后剩余向量构成版本空间。</p><p>注意：含通配符的假设向量可能会和负例一致，一定要谨慎！不要多/少</p></li><li><p>偏好：1.尽可能特殊（适用情况尽可能少）；2.尽可能一般（适用情况尽可能多）；……</p></li></ul><blockquote><p><code>怎么判断是一般还是特殊？</code></p><p>​    <code>数据集中符合新样本属性的各类示例输出结果中多的为一般，少的为特殊。</code></p></blockquote><p>==引导算法确立“正确的”偏好的原则==</p><p>“奥卡姆剃刀”：若有多个假设与观察一致，则选最简单的那个</p>]]></content>
      
      
      
        <tags>
            
            <tag> 西瓜书 笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java复习细节拾遗</title>
      <link href="posts/1486b1bb.html"/>
      <url>posts/1486b1bb.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>[TOC]</p><h1 id="Java复习-细节拾遗"><a href="#Java复习-细节拾遗" class="headerlink" title="Java复习(细节拾遗)"></a>Java复习(细节拾遗)</h1><h2 id="前三章的一点点小知识"><a href="#前三章的一点点小知识" class="headerlink" title="前三章的一点点小知识"></a>前三章的一点点小知识</h2><p><img src="https://s2.loli.net/2022/01/15/uC1xMbDcgjV5dJA.png" alt="1640868328646.png"></p><ol><li>Java语言数据中的数值类型都是有符号(正负号)的，在贮存数值类型的数据时，其最高位用来表示数据的正负号。</li><li>简单类型的变量被声明时，存储空间也同时被分配。该贮存空间只占用一个单一贮存单元。对简单类型变量访问则直接可以得到它的数据。</li><li>引用类型声明变量时，是==不会==为变量(即对象)分配存储空间。它们声明的变量不是数据本身，而是数据的引用(reference)，需用new运算符来为引用类型的变量分配贮存空间，在运行时动态的分配内存大小 .例如:==数组==</li><li>整型类型和boolean类型之间不能相互转换   </li><li>switch所用的表达式为int类型相容的数据表达式，它可以是byte、short、char或者int类型的值，特别要指出的是不能是布尔型的值。</li><li>continue的作用与break类似,主要用于循环,所不同的是break会结束程序块的执行,而continue只会结束其之后程序块的语句,并跳回循环程序块的开头继续下一个循环,而不是离开循环  </li><li>方法中引用类型形参改变实参也会改变(引用类型变量指向的是内存地址,形参和实参指向的是同一内存地址.所以方法对引用型变量的改变会保存下来.</li></ol><h2 id="第四章-面向对象-上"><a href="#第四章-面向对象-上" class="headerlink" title="第四章 面向对象(上)"></a>第四章 面向对象(上)</h2><p>类中定义:成员变量;方法中定义:局部变量。同名变量，方法调用的是==局部变量==。——为避免该情形，提供了==this==关键字。</p><hr><h3 id="This关键字"><a href="#This关键字" class="headerlink" title="This关键字"></a>This关键字</h3><blockquote><p>表示当前对象，指向调用的对象本身（成员变量、成员方法）</p></blockquote><p><img src="https://s2.loli.net/2022/01/15/8Mkq7I26APpHFeE.png" alt="1639315871653.png"></p><blockquote><p>println(this)与println(p)输出的是堆地址；</p><p>相等</p><p>不相等</p></blockquote><h4 id="This的三种用法："><a href="#This的三种用法：" class="headerlink" title="This的三种用法："></a>This的三种用法：</h4><ol><li>使用This调用类中属性（常用于带参构造方法中）</li><li>调用成员方法</li><li>调用构造方法：this([实参列表])</li></ol><p>在构造方法中，使用this调用构造方法的语句==必须位于首行==，==且只能出现一次==</p><p>this调用构造方法时，一定要留一个出口，即至少存在一个构造方法不使用this调用其他构造方法。</p><hr><p>声明一个引用变量：==变量名在栈内存中==（如下图,p1,p2）</p><p>new一个对象：==为对象在堆中分配内存空间==</p><p>一个对象能够被多个变量所引用</p><p><img src="https://s2.loli.net/2022/01/15/v3WAGUs7zucw29Y.png" alt="1639314467617.png"></p><h3 id="垃圾回收"><a href="#垃圾回收" class="headerlink" title="垃圾回收"></a>垃圾回收</h3><blockquote><p>动态存储管理技术，由Java虚拟机自动回收垃圾对象所占的内存空间</p><hr></blockquote><p>在setXxx()方法中，如果对属性有条件制约，那么调用set方法输入被过滤范围内的数值时，原属性仍为初始化值（String:null，int:0）</p><p>类未定义构造方法时，系统会自动提供一个空参构造器，但自己定义构造方法后，<strong>系统==不会==再提供空参构造器。</strong></p><p>重载：多个构造方法，但是参数列表不同。</p><h3 id="static关键字"><a href="#static关键字" class="headerlink" title="static关键字"></a>static关键字</h3><blockquote><p>使用static关键字修饰的成员变量称为静态变量或类变量，它被类的所有对象共享，可以通过==类名==直接访问。</p></blockquote><p>未使用static修饰的变量为实例变量，属于具体对象独有，只能通过引用变量访问。</p><p><img src="https://s2.loli.net/2022/01/15/9BFX7S54nwWCxhl.png" alt="1639317286268.png"></p><p>输出：1（初始化为0）</p><p><img src="https://s2.loli.net/2022/01/15/EtQXZU3jVOFDb2W.png" alt="1639317455240.png"></p><p>输出：5</p><p><strong>注：static关键字在修饰变量的时候只能修饰成员变量，==不能修饰方法中的局部变量==</strong></p><blockquote><p>使用static修饰的成员方法，称为静态方法，无需创建类的实例（对象）就可以调用静态方法，其可以通过类名调用。</p></blockquote><p>静态方法==只能访问类的静态成员（静态变量、静态方法）==，不能访问类的实例成员。因为实例成员属于对象，要创建对象才能访问。</p><h3 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h3><blockquote><p>是外部类的一个成员，内部类可以访问外部类的任何成员（包括私有成员:外部类名.this.外部类私有成员变量），外部类不能直接访问内部类成员。</p><p>可为静态，可以用Protect和private修饰（外部类不能，只能public和默认）</p><p>经Java编译器编译后生成的外部类与内部类是独立的</p></blockquote><p>在外部类中访问内部类需要==创建内部类的对象==使用内部类的对象访问其中成员。</p><p>若在外部类==外==访问内部类，则需要通过外部类对象去创建内部类对象</p><p><code>外部类名.内部类名 引用变量名=new 外部类名().内部类名()</code></p><h2 id="第五章-面向对象（下）"><a href="#第五章-面向对象（下）" class="headerlink" title="第五章 面向对象（下）"></a>第五章 面向对象（下）</h2><h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><p>方法重写：子类重写的方法不能拥有比父类方法更加严格的访问权限。</p><p>重载：在同一个类中，方法名相同，但参数个数或参数类型不同</p><p>重写：子类与父类之间，方法名、返回值类型和参数列表相同。</p><p>子类中访问父类里被重写的方法：super</p><p>在一个构造方法中调用重载的另一个构造方法使用关键字：this；在子类构造方法中调用父类构造方法使用关键字supper（同样要位于构造方法第一行）</p><p>子类中如果没有显式的调用父类的构造方法，将自动调用父类的空参构造方法（若父类没有空参构造方法，则会报错）</p><h3 id="final关键字"><a href="#final关键字" class="headerlink" title="final关键字"></a>final关键字</h3><blockquote><p>用它修饰的类、方法、变量不可以修改：类不能被继承；方法不能被子类重写；变量为常量，初始化后不能再修改。</p></blockquote><p>Java虚拟机不会为final修饰的变量默认初始化——==用final修饰成员变量时，需要在声明时立即初始化，或在构造方法中初始化==</p><p>可以修饰引用变量：表示只能是中引用一个对象，但对象的内容可以更改。</p><h3 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h3><blockquote><p>抽象方法：不含方法体的方法。</p><p>包含抽象方法的类==必须是抽象类==，抽象类可以==不包含任何抽象方法==</p></blockquote><p>抽象类不可以实例化（不能用new创建对象）——必须通过子类继承抽象类去实现抽象方法。(具体子类==必须实现抽象父类中的所有方法==,否则子类必须声明为抽象类.</p><p><strong>抽象方法</strong>（不是抽象类!注意区分）不能用static（可通过类名访问）、final（不能重写）、private（==子类不能访问带private的抽象方法==）关键字修饰。</p><p><strong>注：子类并==不是==能够继承父类的所有属性和方法，子类只能够继承父类的非私有成员。</strong></p><p>抽象类可以定义<strong>构造方法</strong>与成员变量！！！——如果抽象类有构造方法（构造方法允许有方法体），则子类的构造方法中必须先对抽象类进行构造【supper(参数列表)】==子类构造时会默认调用父类中无参构造方法==。</p><h3 id="接口（interface"><a href="#接口（interface" class="headerlink" title="接口（interface"></a>接口（interface</h3><p><strong>变量默认为public static final,方法默认为public abstract。</strong></p><p>implements实现接口（允许==多个==</p><table><thead><tr><th>区别点</th><th>接口</th><th>抽象类</th></tr></thead><tbody><tr><td>含义</td><td>接口通常用于描述一个类的外围能力，而不是核心特征</td><td>抽象类定义了他的子类的核心特征。</td></tr><tr><td>方法</td><td>接口只提供方法声明</td><td>抽象类可以提供完整方法（==抽象类不一定含有抽象方法==）、默认构造方法以及用于覆盖的方法声明。</td></tr><tr><td>变量</td><td>只包含public static final常量，必须在声明时初始化</td><td>可以包含实例变量和静态变量</td></tr><tr><td>多重继承</td><td>一个类可以继承多个接口</td><td>一个类只能继承一个抽象类</td></tr><tr><td>实现类</td><td>类可以实现多个接口</td><td>类只从抽象类派生,必须重写</td></tr></tbody></table><h3 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h3><blockquote><p>同一操作作用于不同的对象可以有不同的解释.</p></blockquote><p><img src="https://s2.loli.net/2022/01/15/FXpT6uAJDz8d4om.png" alt="1639491096792.png"></p><p>方法的实现是由变量的==实际类型==决定的。</p><p>多态体现的是==向上转型==,也称隐式转换。</p><p>向下转型必须强制转换：</p><p><code>Person p=new Child();//向上转型</code></p><p><code>Parent o =(Parent)p;//向下转型</code></p><p><img src="https://s2.loli.net/2022/01/15/wR5ubgjCsoXJSkG.png" alt="1639491670509.png"></p><p><img src="https://s2.loli.net/2022/01/15/F9m6yajg7AZ8MHQ.png" alt="1639491747777.png"></p><p><img src="https://s2.loli.net/2022/01/15/IKCfAeJlaY8QkHw.png" alt="1639492138248.png"></p><p>equals类默认比较的是引用变量地址（==也是）；String类中的equals被重写为比较两字符串内容是否相等。</p><h3 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h3><h4 id="线程的安全性问题"><a href="#线程的安全性问题" class="headerlink" title="==线程的安全性问题=="></a>==线程的安全性问题==</h4><p>1.同步代码块</p><h2 id="IO流"><a href="#IO流" class="headerlink" title="IO流"></a>IO流</h2><h3 id="FileInputStream"><a href="#FileInputStream" class="headerlink" title="FileInputStream"></a>FileInputStream</h3><p>finally不能直接访问try中的内容,为防止程序中断后,流无法释放占用资源,==一定要将close方法写在finally中==,流要定义在==try外面==</p><p><img src="https://s2.loli.net/2022/01/15/YThykrqg1wbZ5WK.png" alt="1641101856200.png"></p>]]></content>
      
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode No.7</title>
      <link href="posts/c5bc31ac.html"/>
      <url>posts/c5bc31ac.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>[TOC]</p><h1 id="LeetCode题解（7-整数反转）"><a href="#LeetCode题解（7-整数反转）" class="headerlink" title="LeetCode题解（7.整数反转）"></a>LeetCode题解（7.整数反转）</h1><h2 id="题面"><a href="#题面" class="headerlink" title="题面"></a>题面</h2><blockquote><p>给你一个 32 位的有符号整数 x ，返回将 x 中的数字部分反转后的结果。</p><p>如果反转后整数超过 32 位的有符号整数的范围 [−231,  231 − 1] ，就返回 0。<br>假设环境不允许存储 64 位整数（有符号或无符号）。</p><p>示例 1：</p><p>输入：x = 123<br>输出：321</p><p>示例 2：</p><p>输入：x = -123<br>输出：-321</p><p>示例 3：</p><p>输入：x = 120<br>输出：21</p><p>示例 4：</p><p>输入：x = 0<br>输出：0</p><p>提示：</p><p> -231 &lt;= x &lt;= 231 - 1</p></blockquote><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>整数反转算是烂大街的（不是）考题了，其实看到反转第一反应是栈……但是对付整数来讲略微小题大做。</p><p>最无脑的反转方法就是x/10,x%10,x%100……得到x每一位上的数字然后再乘回去，从这种无脑的思想中其实可以总结出一个公式：result = result*10+x%10;x=x/10; 构成循环，循环的终止条件自然就是x==0，这种情况，while最合适了。</p><p>这里记录一下我犯过的愚蠢错误：</p><ol><li>倒在单词拼写上的女人：while我再也不会拼错啦</li><li>x/10和x%10:前者是得到去除个位后的数字，后者是取当前个位数字（老是搞混，呜呜</li></ol><p>但是！这道题最膈应人的地方并不是如何把整数反转（因为它实在是太简单了</p><hr><p>这道题的重头应该在于==特殊情况的输出如何进行判断==</p><p>如题，我们最后的结果result在超过一定范围后要输出0，所以显然我们要对result取值进行判断，但是==假设环境不允许存储 64 位整数（有符号或无符号）。==</p><p>？？？</p><p>这怎么搞</p><p>环境不允许存储64位整数意味着无法写该范围————怎么处理？</p><p>这时候想到了long 64位，如果将64位long强转为int也相等……OK</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">reverse</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">long</span> result <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">while</span><span class="token punctuation">(</span>x<span class="token operator">!=</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            result<span class="token operator">=</span>result<span class="token operator">*</span><span class="token number">10</span><span class="token operator">+</span>x<span class="token operator">%</span><span class="token number">10</span><span class="token punctuation">;</span>            x<span class="token operator">=</span>x<span class="token operator">/</span><span class="token number">10</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span>result <span class="token operator">==</span> result<span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span>result<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">else</span>            <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://s2.loli.net/2022/01/15/trMdhYxR1fpwzL4.png" alt="1638237528394.png"></p>]]></content>
      
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
