<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>机器学习笔记(二)</title>
      <link href="posts/748fe819.html"/>
      <url>posts/748fe819.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="机器学习-模型评估与选择"><a href="#机器学习-模型评估与选择" class="headerlink" title="机器学习  模型评估与选择"></a>机器学习  模型评估与选择</h1><h2 id="经验误差与过拟合"><a href="#经验误差与过拟合" class="headerlink" title="经验误差与过拟合"></a>经验误差与过拟合</h2><h3 id="本篇概念及缩写汇总"><a href="#本篇概念及缩写汇总" class="headerlink" title="本篇概念及缩写汇总:"></a>本篇概念及缩写汇总:</h3><p>错误率：分类错误的样本数占样本总数的比例 </p>]]></content>
      
      
      
        <tags>
            
            <tag> 机器学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="posts/0.html"/>
      <url>posts/0.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>title: 计算机操作系统(二)<br>tags: 操作系统<br>abbrlink: 8c2e937<br>date: 2022-01-20 18:06:40</p><h1 id="进程的描述与控制"><a href="#进程的描述与控制" class="headerlink" title="进程的描述与控制"></a>进程的描述与控制</h1><h2 id="前趋图与程序执行"><a href="#前趋图与程序执行" class="headerlink" title="前趋图与程序执行"></a>前趋图与程序执行</h2><p><strong>前趋图</strong>用于描述程序执行的先后顺序。</p><p><img src="https://s2.loli.net/2022/01/20/QpgWzeNRfnPk8xb.png" alt="image.png"></p><p>前趋图中的每个结点可用来表示一个进程或程序段，乃至一条语句，结点间的有向边则表示两个结点之间存在的偏序或前趋关系。</p><p><strong>前趋图中不允许有循环</strong></p><p>合理前趋图：</p><p><img src="https://s2.loli.net/2022/01/20/a3AeMy2VztIjiXc.png" alt="image.png"></p><p>如上图，存在以下前趋关系：</p><p>P1→P2,P1→P3,P1→P4,P2→P5,P3→P5,P4→P6,P4→P7,P5→P8,P6→P8,P7→P9,P8→P9</p><p>或表示为：</p><p>P={P1,P2,P3,P4,P5,P6,P7,P8,P9}</p><p>  ={(P1,P2),(P1,P3),(P1,P4),(P2,P5),(P3,P5),(P4,P6),(P4,P7),(P5,P8),(P6,P8),(P7,P9),(P8,P9)}</p><p>不正确的前趋图（具有循环）：</p><p><img src="https://s2.loli.net/2022/01/20/Y6y1CPhTtwJfv4O.png" alt="1642682545729.png"></p><p>S2→S3，S3→S2，显然是无法实现的。</p><h4 id="程序顺序执行"><a href="#程序顺序执行" class="headerlink" title="程序顺序执行"></a>程序顺序执行</h4><p><img src="https://s2.loli.net/2022/01/20/KzslmiI6Zw1Q4j2.png" alt="image.png"></p><p><strong>程序顺序执行时的特征：</strong></p><ol><li><p>顺序性</p><p>指处理机严格地按照程序所规定的顺序执行，即每一操作必须在下一个操作开始之前结束；</p></li><li><p>封闭性</p><p>指程序在封闭的环境下运行，即程序运行时独占全机资源，资源的状态（除初始状态之外）只有本程序才能改变它，程序一旦开始执行，其执行结果不受外界因素影响；</p></li><li><p>可再现性</p><p>指只要程序执行时的环境和初始条件相同，当程序重复执行时，不论它是从头到尾不停顿地执行，还是“停停走走”地执行，都可获得相同的结果。</p></li></ol><h4 id="程序并发执行"><a href="#程序并发执行" class="headerlink" title="程序并发执行"></a>程序并发执行</h4><p>以打印为例：由输入程序（I）、计算程序（C）、打印程序（P）组成，单个打印作业存在Ii→Ci→Pi这样的顺序执行的前趋关系，但对于多个打印作业如果全部按照顺序方式执行依次输入，则对于CPU利用率较小，故采用并发方式执行：</p><p><img src="https://s2.loli.net/2022/01/20/BX7bMSaikKtDPVW.png" alt="image.png"></p><p>由图可以看出Pi-1和Ci以及Ii+1之间不存在前趋关系，可以并发执行。</p><p><strong>程序并发执行时的特征</strong></p><ol><li><p>间断性</p><p>程序在并发执行时，由于它们共享系统资源，以及为完成同一项任务而相互合作，致使在这些并发程序之间形成了相互制约的关系。</p></li><li><p>失去封闭性</p><p>资源共享</p></li><li><p>不可再现性</p><p>由于失去封闭性，导致其失去了不可再现性，即使执行的环境和初始条件相同也不一定得到相同结果。与执行速度有关。</p></li></ol><h2 id="进程的描述"><a href="#进程的描述" class="headerlink" title="进程的描述"></a>进程的描述</h2><blockquote><p>①进程是程序的一次执行；</p><p>②进程是一个程序及其数据在处理机上顺序执行时所发生的活动；</p><p>③进程是具有独立功能的程序在一个数据集合上运行的过程，它是系统进行资源分配和调度的一个独立单位。</p><p>进程是进程实体的运行过程，是系统进行资源分配和调度的一个独立单位。</p></blockquote><p>为什么要引入进程这个概念？所有事物的发展都是从简单到复杂，而在最初，程序执行往往是连续的、封闭的、可再现的，也就是说顺序执行，这也是通常的程序具有的一般性质，那么如何使程序能够并发执行，并且对这种并发加以描述和控制呢？就引入进程这一概念，所以进程往往具有程序并发执行的一些特征。</p><p><strong>PCB</strong></p><blockquote><p>为了使参与并发执行的每个程序（含数据）都能独立运行，在操作系统中必须为之配置一个专门的数据结构，称为进程控制块（PCB）</p></blockquote><p>由<strong>程序段</strong>、<strong>相关的数据段</strong>和<strong>PCB</strong>三部分就构成了进程实体，一般情况下简称为进程。</p><p>创建进程：创建进程实体中的PCB</p><p>撤销进程：撤销进程的PCB</p><p><strong>进程的特征</strong></p><table><thead><tr><th align="center">进程</th><th align="center">程序</th></tr></thead><tbody><tr><td align="center">①动态性  进程的实质是进程实体的执行过程，具有一定的生命期，创建（产生）—调度（执行）—撤销（消亡）</td><td align="center">静态的  只是一组有序指令的集合，本身不具有活动的含义</td></tr><tr><td align="center">②并发性  多个进程实体同存在于内存之中，且能在同一段时间内同时运行（也是引入进程的目的所在）</td><td align="center">程序（没有建立PCB）是不能参与并发执行的</td></tr><tr><td align="center">③独立性  进程实体是一个能独立运行、独立获得资源和独立接受调度的基本单位</td><td align="center">凡未建立PCB的程序都不能作为一个独立的单位参与运行</td></tr><tr><td align="center">④异步性  进程按各自独立的、不可预知的速度向前推进</td><td align="center">传统意义上的程序若参与并发执行，会产生其结果的不可再现性。</td></tr></tbody></table><p>备注：针对④，为使进程在并发运行时虽具有异步性，但仍能保证进程并发执行的结果是可再现的，在OS中引进了进程的概念，并配置相应的进程同步机制。</p><h3 id="进程的状态及转换"><a href="#进程的状态及转换" class="headerlink" title="进程的状态及转换"></a>进程的状态及转换</h3><p>一般而言，进程应至少处于就绪、执行、阻塞三种基本状态之一。</p><p><img src="https://s2.loli.net/2022/01/22/IJtKW6HGbYCe7sM.png" alt="image.png"></p><h4 id="三种基本状态以及转换"><a href="#三种基本状态以及转换" class="headerlink" title="三种基本状态以及转换"></a>三种基本状态以及转换</h4><p>（1）就绪状态：除了CPU以外的全部资源都已经准备好。如果系统中有多个处于就绪状态的进程，通常将它们按照一定的策略（如优先级策略）排成<strong>就绪队列</strong>。</p><p>（2）执行状态：已获得CPU，正在执行的状态。   通常单处理机中只有一个进程处于执行状态；多处理机中可有多个进程处于执行状态。</p><p>（3）阻塞状态：正在执行的进程由于发生某事件（如I/O请求、申请缓冲区失败等）暂时无法继续执行的状态，亦即进程的执行受到阻塞。      此时引起进程调度，OS将处理机分配给另一个就绪进程，而让受阻进程处于暂停状态。     阻塞队列：通常根据阻塞原因不同，设置多个阻塞队列。</p><p>就绪状态→<strong>调度程序为之分配处理机</strong>→执行状态→<strong>分配给它的时间片已完成被剥夺处理机暂停执行</strong>→就绪状态</p><p>执行状态→<strong>发生某事件使进程受阻，使之无法继续执行</strong>→阻塞状态</p><p>某事件举例：进程访问某临界资源，而该资源正被其他进程访问。</p><h4 id="创建进程以及创建状态"><a href="#创建进程以及创建状态" class="headerlink" title="创建进程以及创建状态"></a>创建进程以及创建状态</h4><p><img src="https://s2.loli.net/2022/01/22/F2boTfNzdkX8EwC.png" alt="image.png"></p><h4 id="进程的终止与终止状态"><a href="#进程的终止与终止状态" class="headerlink" title="进程的终止与终止状态"></a>进程的终止与终止状态</h4><p>进程的终止需要两个步骤：等待操作系统进行善后处理（其他进程对其信息进行提取【保留记录】）；将其PCB清零，并将PCB空间返还系统。</p><p>终止条件：</p><ul><li><p>进程到达了自然临界点</p></li><li><p>出现了无法克服的错误</p></li><li><p>被操作系统所终结</p></li><li><p>被其他有终止权的进程终结</p><p>（详见本篇进程控制部分）</p></li></ul><p>被终止后的进程以后不再执行，但在操作系统中依然保留一个记录，其中保存状态码和一些及时统计数据，供其它进程收集。</p><h4 id="挂起操作和进程状态转换"><a href="#挂起操作和进程状态转换" class="headerlink" title="挂起操作和进程状态转换"></a>挂起操作和进程状态转换</h4><blockquote><p>挂起：意味着此时进程处于静止状态——&gt;不能被调度/暂停执行</p><p>激活：与挂起操作相对应</p></blockquote><p>由此，产生了活动就绪、静止就绪；活动阻塞、静止阻塞</p><p><strong>引入挂起操作的原因</strong></p><ol><li><p>终端用户的需要</p></li><li><p>父进程请求</p></li><li><p>负荷调节的需要</p></li><li><p>操作系统的需要</p><p>总的来讲，是为了排查或者避免一些运行中的问题、协调进程活动。</p></li></ol><p><img src="https://s2.loli.net/2022/01/22/uLmUkHFSz47wCYg.png" alt="image.png"></p><p>就绪：进程在内存，准备执行</p><p>阻塞：进程在内存，等待执行</p><p>就绪挂起：进程在外存，暂时不调度</p><p>阻塞挂起：进程在外存</p><h3 id="进程管理中的数据结构——进程表PCB"><a href="#进程管理中的数据结构——进程表PCB" class="headerlink" title="进程管理中的数据结构——进程表PCB"></a>进程管理中的数据结构——进程表PCB</h3><blockquote><p><strong>PCB</strong>的作用：是一个在多道程序环境下不能独立运行的程序（含数据）成为一个能独立运行的基本单位，一个能与其他进程并发执行的进程。</p><p>（1）作为独立运行基本单位的标志</p><p>（2）能实现间断性运行方式</p><p>（3）提供进程管理所需要的信息</p><p>（4）提供进程调度所需要的信息</p><p>（5）实现与其他进程的同步与通信</p></blockquote><p><img src="https://s2.loli.net/2022/01/22/TBgY1oJNrkx7dKn.png" alt="image.png"></p><h4 id="进程控制块的组织方式"><a href="#进程控制块的组织方式" class="headerlink" title="进程控制块的组织方式"></a>进程控制块的组织方式</h4><blockquote><p>在一个系统中，通常可以有数十个、数百个乃至数千个PCB。为了能对它们加以有效的管理，应采用适当的方式对其进行组织。</p></blockquote><p>（1）线性方式</p><p>将系统中所有PCB组织在一张表中，将该表的首址存放在内存的一个专用区域中。</p><p><img src="https://s2.loli.net/2022/01/22/2UDdSTWxhLY9Qjl.png" alt="image.png"></p><p>优点：简单、开销小</p><p>缺点：每次查找时都需要扫描整张表，效率较低</p><p>适用于进程数目不多的系统</p><p>（2）链接方式</p><p>将具有相同状态进程的PCB分别通过PCB中的链接字链接成一个队列。</p><p><img src="https://img-blog.csdnimg.cn/20200926222207588.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NTU2NTk5,size_16,color_FFFFFF,t_70#pic_center" alt="image.png"></p><p>对就绪队列而言，往往按进程的优先级将PCB从高到低进行排列，将优先级高的进程PCB排在队列的前面。</p><p>（3）索引方式</p><p>系统根据所有进程状态不同，建立几张索引表，并把个索引表在内存的首地址记录在内存的一些专用单元中。在每个索引表的表目中，记录具有相应状态的某个PCB在PCB表中的地址。</p><p><img src="https://img-blog.csdnimg.cn/2020092622230441.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NTU2NTk5,size_16,color_FFFFFF,t_70#pic_center" alt="image.png"></p><h2 id="进程控制"><a href="#进程控制" class="headerlink" title="进程控制"></a>进程控制</h2><h4 id="操作系统内核"><a href="#操作系统内核" class="headerlink" title="操作系统内核"></a>操作系统内核</h4><blockquote><p>现代操作系统一般将OS划分为若干层次，再将OS的不同功能分别设置在不同的层次中。通常将一些<strong>与硬件紧密相关的模块</strong>（如中断处理程序等）、<strong>各种常用设备的驱动程序</strong>、<strong>运行频率较高的程序</strong>（如时钟管理、进程调度和许多模块公用的一些基本操作），都安排在紧靠硬件的软件层次中，将它们常驻内存，即通常被称为的OS内核。</p></blockquote><p>目的：</p><p>便于对这些软件进行保护，防止遭受其他应用程序的破坏；</p><p>提高OS的运行效率。</p><p>功能：</p><ol><li><p>支撑功能</p><p>提供给OS其他众多模块所需要的一些基本功能，以便支撑这些模块工作。</p><p>（1）中断处理 内核最基本的功能</p><p>（2）时钟管理</p><p>（3）原语操作  所谓原语，就是由若干条指令组成的，用于完成一定功能的一个过程。</p><p>与一般过程的区别：原语为“原子操作”，一个操作中所有动作要么全做，要么不做，是一个不可分割的基本单位。<strong>因此，原语在执行过程中不允许被中断</strong>。</p></li><li><p>资源管理功能</p><p>（1）进程管理</p><p>（2）存储器管理</p><p>（3）设备管理</p></li></ol><h4 id="进程的创建"><a href="#进程的创建" class="headerlink" title="进程的创建"></a>进程的创建</h4><p><strong>进程的层次结构</strong></p><ul><li>父进程与子进程：把创建进程的进程称为父进程，把被创建的进程称为子进程，子进程可以继续创建更多的进程。</li><li>进程间的继承关系：子进程可以继承父进程所拥有的资源（父进程打开的文件、分配到的缓冲区等）子进程被撤销时，应将其从父进程那里获得的资源归还给父进程；在撤销父进程时，也必须同时撤销其所有的子进程。进程不能拒绝其子进程的继承权。</li><li>Windows 句柄：不存在任何进程层次的概念，所有进程具有同等地位。如果一个进程创建另外的进程时获得一个句柄，其作用相当于一个令牌，可以用来控制被创建的进程。但是，<strong>这个句柄是可以进行传递的</strong>。获得句柄的进程就拥有了控制其他进程的权力。</li></ul><p><strong>进程图</strong></p><p>（类似树）结点为进程。</p><p><strong>引起创建进程的事件</strong></p><p>（1）用户登录</p><p>（2）作业调度</p><p>（3）提供服务</p><p>（4）应用请求</p><p><strong>进程的创建</strong></p><p>（1）申请空白PCB</p><p>（2）为新进程分配其运行所需的资源，包括各种物理和逻辑资源</p><p>（3）初始化进程控制块</p><p>​        ①初始化标识信息（系统分配的标识符和父进程标识符）</p><p>​        ②初始化处理机状态信息，使程序计数器指向程序的入口地址，使栈指针指向栈顶</p><p>​        ③初始化处理机控制信息，（状态：就绪/精致就绪；优先级）</p><p>（4）插入队列</p><h4 id="进程的终止"><a href="#进程的终止" class="headerlink" title="进程的终止"></a>进程的终止</h4><p><strong>引起进程终止的事件</strong></p><p>（1）正常结束</p><p>（2）异常结束</p><p>​        ①越界错 程序访问的存储区越出该进程区域</p><p>​        ②保护错 进程试图去访问一个不允许访问的资源或文件或以不适当的形式进行访问</p><p>​        ③非法指令 程序试图去执行一条不存在的指令</p><p>​        ④特权指令错 用户试图去执行一条只允许OS执行的指令</p><p>​        ⑤运行超时</p><p>​        ⑥等待超时</p><p>​        ⑦算术运算错</p><p>​        ⑧I/O故障</p><p><strong>进程的终止过程</strong></p><p>（1）根据标识符，读出该进程状态</p><p>（2）终止该进程，置调度标志为真</p><p>（3）终止子进程</p><p>（4）资源归还父进程</p><p>（5）移出队列，等待其他进程搜集信息</p><h4 id="进程的阻塞与唤醒"><a href="#进程的阻塞与唤醒" class="headerlink" title="进程的阻塞与唤醒"></a>进程的阻塞与唤醒</h4><p>阻塞原语：block</p><p>唤醒原语：wakeup   </p><p><strong>block原语和wakeup原语必须成对使用</strong></p><p>挂起原语：suspend</p><p>激活原语：active</p><p><strong>引起进程阻塞或唤醒的事件</strong></p><ol><li>向系统请求共享资源失败</li><li>等待某种操作完成</li><li>新数据尚未到达</li><li>等待新任务的到达</li></ol><p><strong>进程阻塞的过程</strong></p><p><strong><em>阻塞是进程自身的一种主动行为</em></strong>。正在执行的进程，若发生上述事件，<strong>进程</strong>便通过调用阻塞原语block将自己阻塞。</p><p>状态设置——插入队列——重新调度</p><p><strong>进程唤醒的过程</strong></p><p>调用唤醒原语wakeup</p><p>移出队列——状态设置——插入队列</p><h2 id="进程同步"><a href="#进程同步" class="headerlink" title="进程同步"></a>进程同步</h2><h3 id="进程同步的基本概念"><a href="#进程同步的基本概念" class="headerlink" title="进程同步的基本概念"></a>进程同步的基本概念</h3><p>我们还记得多道批处理时是不可再现的，这对我们检查、定位、修正异常带来了麻烦，进程和进程同步机制就是为了使多道批处理具有可再现性。</p><p>进程同步机制的主要任务，是对多个相关进程在执行次序上进行协调，使并发执行的诸进程之间能按照一定的规则（或时序）共享系统资源，并能很好的相互合作，从而使程序的执行具有可再现性。</p><p>1）间接相互制约  由于共享系统资源形成的相互制约关系</p><p>2）直接相互制约  未完成某任务而建立的多个进程，源于彼此间相互合作的制约关系。</p><p><strong>临界资源</strong>  采取互斥方式，实现对这类资源的共享</p><p>访问临界资源的代码段称为<strong>临界区</strong>。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>操作系统学习笔记(一)</title>
      <link href="posts/392e0872.html"/>
      <url>posts/392e0872.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="计算机操作系统-一"><a href="#计算机操作系统-一" class="headerlink" title="计算机操作系统(一)"></a>计算机操作系统(一)</h1><blockquote><p>操作系统是配置在计算机硬件上的第一层软件,是对硬件系统的首次扩充,其主要作用是管理好这些设备,提高它们的利用率和系统的吞吐量,并为用户和应用程序提供一个简单的接口,便于用户使用。</p></blockquote><h2 id="操作系统的目标、作用及发展过程"><a href="#操作系统的目标、作用及发展过程" class="headerlink" title="操作系统的目标、作用及发展过程"></a>操作系统的目标、作用及发展过程</h2><h3 id="操作系统的目标"><a href="#操作系统的目标" class="headerlink" title="操作系统的目标"></a>操作系统的目标</h3><ul><li><p><strong>方便性</strong></p><p>裸机使用→机器语言</p><p>配置OS→高级语言编写的程序或OS提供的命令→方便用户、易学易用</p></li><li><p>有效性</p><p>提高系统资源的利用率</p><p>提高系统的吞吐量</p></li><li><p><strong>可扩充性</strong></p><p>为适应计算机硬件、体系结构以及计算机应用发展的要求。</p><p>无结构→模块化结构→层次化结构→微内核结构</p></li><li><p>开放性</p><p>硬件与软件的兼容性</p><p>系统能遵循世界标准规范→统一的开放环境以实现应用的可移植性与互操作性</p><p>不同设备间可以通过网络集成，正确有效的协同工作</p></li></ul><h3 id="操作系统的作用"><a href="#操作系统的作用" class="headerlink" title="操作系统的作用"></a>操作系统的作用</h3><ol><li><p>作为用户与计算机硬件系统之间的接口；</p><p>（1）命令方式</p><p>（2）系统调用方式</p><p>（3）图标—窗口方式</p></li><li><p>作为计算机系统资源的管理者；</p><p><strong>计算机系统资源（四类</strong>）：处理机、存储器、I/O设备、文件（数据和程序）</p></li><li><p>实现了对计算机资源的抽象；</p></li></ol><h3 id="操作系统的发展过程"><a href="#操作系统的发展过程" class="headerlink" title="操作系统的发展过程"></a>操作系统的发展过程</h3><p>人工操作→单道批处理→多道批处理→分时系统→实时系统（优缺点）</p><h2 id="操作系统的基本特性"><a href="#操作系统的基本特性" class="headerlink" title="操作系统的基本特性"></a>操作系统的基本特性</h2><ol><li><p>并发</p><blockquote><p><strong>·</strong> <strong>并行与并发</strong></p></blockquote><blockquote><p><strong>并行性</strong>：两个或多个事件在同一**<em>时刻**</em>发生。</p><p><strong>并发性</strong>：两个或多个事件在同一**<em>时间间隔**</em>内发生。</p></blockquote><p>多道程序环境下：宏观上有多个程序在同时运行，但在单处理机系统中，每一时刻仅能有一道程序执行→微观上为分时交替进行→*<strong>并发**<em>。但是如果有多个处理机，这些可以并发执行的程序可以分配给不同处理机执行→</em></strong>并行***，实现微观意义上的同时进行。</p><blockquote><p><strong>·</strong> 进程与线程</p></blockquote><p>未引入进程：计算程序与I/O程序（CPU空闲）间顺序执行。对计算程序和I/O程序分别设立进程：可以并发执行。</p><p>引入进程：程序为静态的。进程为程序的执行→提高系统资源利用率，增加系统的吞吐量。</p><p>引入线程：进程的更小的可执行单位，一个进程可包含若干个进程。</p></li><li><p>共享</p><p>一般情况下共享与操作系统环境下的共享其含义并不相同：前者未限定借阅者必须在同一时间或间隔和同一地点进行共享；而在OS环境下的共享是指系统中的资源可供内存中多个并发执行的进程(线程)共同使用。 这里在<strong>宏观上</strong>既限定了时间（进程在内存期间内），也限定了地点（内存）。</p><p>由于资源属性的不同，进程对资源共享的方式也不同，目前主要有以下两种资源共享方式：<br><strong>互斥共享方式</strong><br>系统中的某些资源，如打印机、磁带机，虽然它们可以提供给多个进程(线程)使用，但为使所打印或记录的结果不致造成混淆，应规定在一段时间内只允许一个进程(线程)访问该资源，我们把这种资源共享方式称为互斥式共享。<br>临界资源或独占资源：一段时间内只允许一个进程访问的资源。计算机系统中的大多数物理设备，以及某些软件中所用的栈、变量和表格，都属于临界资源，它们要求被互斥地共享。<br><strong>同时访问方式</strong><br>允许在一段时间内由多个进程 “同时”对它们进行访问。这里所谓的“同时”往往是宏观上的，而在<strong>微观上</strong>，这些进程可能是交替地对该资源进行访问。<br>并发和共享是多用户(多任务)OS的两个最基本的特征。它们又是互为存在的条件。</p></li><li><p>虚拟</p><blockquote><p>在OS中,把通过某种技术将一个物理实体变为若干个逻辑上的对应物的功能称为”虚拟” 。前者为实体，后者则是虚的，是用户感觉上的东西。相应的，把用于实现虚拟的技术称为虚拟技术。</p></blockquote><p>“空分复用”或”时分复用”技术,将一条物理信道变为若干条逻辑信道.</p><p><em>时分复用技术</em></p><p>利用某<strong>设备</strong>为一用户服务的空闲时间，又转去为其他用户服务，使设备得到最充分的利用。</p><blockquote><p>⑴虚拟处理机技术：在虚拟处理机技术中，是通过多道程序设计技术，让多道程序并发执行的方法，来<strong>分时</strong>使用一台处理机的。（宏观）<br>⑵虚拟设备技术：将一台物理I/O设备虚拟为多台逻辑上的I/O设备，并允许每 个用户占用一台逻辑上的I/O设备，这样便可使原来仅允许在 一段时间内由一个用户访问的设备(即临界资源)，变为在一 段时间内允许多个用户同时访问的共享设备。</p><p>在操作系统中，虚拟的实现主要是通过分时复用的方法。显然，如果 n 是某物理设备所对应的虚拟的逻辑设备数，则虚拟设备的平均速度必然等于或低于物理设备速度的1 / n 。</p></blockquote><p><em>空分复用技术</em></p><p>利用<strong>存储器</strong>的空闲空间分区域存放和运行其他的多道程序，以此来提高内存的利用率。</p><p>类似分时复用技术，虚拟设备平均占用空间必然也低于或等于1/n。</p></li><li><p>异步</p><p>由于资源等因素的限制，使进程的执行通常都不是“一气呵成”， 而是以“停停走走”的方式运行。<br>内存中的每个进程在何时能获得处理机运行，何时又因提出某种资源请求而暂停，以及进程以怎样的速度向前推进，每道程序总共需多少时间才能完成，等等，都是不可预知的。由于各用户程序性能的不同，比如，有的侧重于计算而较少需要 I/O；而又有的程序其计算少而I/O多，这样，很可能是先进入内存的作业后完成；而后进入内存的作业先完成。或者说，<strong>进程是以人们不可预知的速度向前推进，此即进程的异步性</strong>。尽管如此，但只要运行环境相同，作业经多次运行，都会获得完全相同的结果。因此，异步运行方式是允许的，是操作系统的一个重要特征。</p></li></ol><h2 id="操作系统的主要功能"><a href="#操作系统的主要功能" class="headerlink" title="操作系统的主要功能"></a>操作系统的主要功能</h2><ol><li><p>处理机管理功能</p><ul><li>进程控制  为作业创建进程、撤销或终止已结束的进程、以及控制进程在运行中的状态转换。</li><li>进程同步  ①<strong>进程互斥方式</strong>②<strong>进程同步方式</strong></li><li>进程通信  实现相互合作进程之间的信息交换</li><li>调度          包括作业调度和进程调度两步：作业调度：将作业调入内存后，分别为他们建立进程；进程调度：按照一定的算法选出一个进程</li></ul></li><li><p>存储器管理功能</p><ul><li><p>内存分配  为每道程序分配内存空间；提高存储器的利用率；允许正在运行的程序申请附加的内存空间，以适应程序和数据动态增长的需要。</p></li><li><p>​     静态分配  作业的内存空间是在作业装入是确定的，装入后的运行期间不允许改作业申请新的内存空间或者改变内存空间（即不允许作业在内存中“移动”）。</p></li><li><p>​     动态分配  允许在运行期间申请新的内存空间和移动。</p></li><li><p>内存保护  确保每道用户程序都仅在自己的内存空间内运行，彼此互不干扰。</p><p>​                 绝不允许用户程序访问操作系统的程序和数据，也不允许用户程序转移到非共享的其它用户程序中去执行。</p></li><li><p>地址映射  逻辑地址与物理地址</p></li><li><p>内存扩充  逻辑上扩充内存容量（虚拟）</p></li></ul></li><li><p>设备管理功能</p><ul><li><p>缓冲管理  ①缓和I/O设备和CPU之间速度不匹配的矛盾，提高CPU利用率。提高系统的吞吐量。</p><p>​                 ②改善系统的性能</p></li><li><p>设备分配</p></li><li><p>设备处理</p></li></ul></li><li><p>文件管理功能</p><ul><li>缓冲管理</li><li>设备分配</li><li>设备处理</li></ul></li><li><p>操作系统与用户之间的接口</p><ul><li>用户接口</li><li>程序接口</li></ul></li><li><p>（现代）系统安全</p></li><li><p>（现代）网络的功能和服务</p></li><li><p>（现代）支持多媒体</p></li></ol><h2 id="操作系统结构设计"><a href="#操作系统结构设计" class="headerlink" title="操作系统结构设计"></a>操作系统结构设计</h2><h4 id="模块化结构设计"><a href="#模块化结构设计" class="headerlink" title="模块化结构设计"></a>模块化结构设计</h4><p><img src="https://s2.loli.net/2022/01/17/oyPSB4heOusbikn.png" alt="image.png"></p><p>模块独立性标准:内聚性,耦合度——高内聚，低耦合。</p><p>模块-接口法优点：</p><p>​    提高OS设计的正确性、可理解性和可维护性。</p><p>​    增强OS的可适应性。</p><p>​    加速OS的开发过程。</p><h4 id="分层式结构"><a href="#分层式结构" class="headerlink" title="分层式结构"></a>分层式结构</h4><ul><li>优点：<br>易保证系统的正确性<br>易拓充<br>易维护</li><li>缺点：<br>系统效率降低</li></ul><h4 id="客户-服务器模式"><a href="#客户-服务器模式" class="headerlink" title="客户/服务器模式"></a>客户/服务器模式</h4><h4 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h4><h4 id="微内核"><a href="#微内核" class="headerlink" title="微内核"></a>微内核</h4>]]></content>
      
      
      
        <tags>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>机器学习Day1</title>
      <link href="posts/8625e497.html"/>
      <url>posts/8625e497.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>[TOC]</p><h1 id="机器学习-Day-1"><a href="#机器学习-Day-1" class="headerlink" title="机器学习 Day.1"></a>机器学习 Day.1</h1><blockquote><p>一般地，令D = {x,x2….x.m}表示包含m个示例的数据集，每个示例由d个属性描述,则每个示例Xi= (xi1;xi2;……;xid) 是d维样本空间X中的一个向量, xi∈x,其中xij是xi在第j个属性上的取值(例如上述第3个西瓜在第2个属性上的值是“硬挺”), d称为样本xi的“维数”(dimensionality).</p></blockquote><h2 id="基础概念"><a href="#基础概念" class="headerlink" title="基础概念"></a>基础概念</h2><ul><li>（属性1 = 取值，属性2 = 取值，……，属性3=取值）——一个示例</li><li>{示例1，示例2，……，示例3}——数据集</li></ul><p>每条示例中所有的属性分别看作一根坐标轴张成==属性空间/样本空间==，则可以把一个示例称为==特征向量==</p><pre class="line-numbers language-mermaid" data-language="mermaid"><code class="language-mermaid">graph LRA[预测任务] --&gt;Z(监督学习)A --&gt;Y(无监督学习)Y--&gt;X(聚类)Z --&gt;B(离散型)  B --&gt; C(分类)    C --&gt;|仅涉及两个类别|F(二分类)    F --&gt;M(y = -1,+1)    C --&gt;|涉及多个类别|G(多分类)    G --&gt;L(y的绝对值&gt;2)  Z --&gt;D(连续型)  D --&gt;E(回归)    E --&gt;N(y=R)  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>泛化能力：学得模型适用于新样本的能力。</li><li>假设空间规模大小：搜索目标是找到能够将训练集中的瓜判断正确的假设。假设的表示一旦确定，假设空间及规模大小也就确定了：（属性1的表示个数<em>属性2的……</em>属性n的表示个数==+1==）</li></ul><p>注：在考虑取值的时候，要考虑==该属性不影响结果==（用通配符*表示）、==不存在要求结果==（输出结果为空）两种容易忽略的情况。</p><ul><li><p>版本空间：根据假设的表示得到假设空间，剔除与样本集中正例（某事发生）不一致的假设向量和与负例一致的假设向量后剩余向量构成版本空间。</p><p>注意：含通配符的假设向量可能会和负例一致，一定要谨慎！不要多/少</p></li><li><p>偏好：1.尽可能特殊（适用情况尽可能少）；2.尽可能一般（适用情况尽可能多）；……</p></li></ul><blockquote><p><code>怎么判断是一般还是特殊？</code></p><p>​    <code>数据集中符合新样本属性的各类示例输出结果中多的为一般，少的为特殊。</code></p></blockquote><p>==引导算法确立“正确的”偏好的原则==</p><p>“奥卡姆剃刀”：若有多个假设与观察一致，则选最简单的那个</p>]]></content>
      
      
      
        <tags>
            
            <tag> 西瓜书 笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java复习细节拾遗</title>
      <link href="posts/1486b1bb.html"/>
      <url>posts/1486b1bb.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>[TOC]</p><h1 id="Java复习-细节拾遗"><a href="#Java复习-细节拾遗" class="headerlink" title="Java复习(细节拾遗)"></a>Java复习(细节拾遗)</h1><h2 id="前三章的一点点小知识"><a href="#前三章的一点点小知识" class="headerlink" title="前三章的一点点小知识"></a>前三章的一点点小知识</h2><p><img src="https://s2.loli.net/2022/01/15/uC1xMbDcgjV5dJA.png" alt="1640868328646.png"></p><ol><li>Java语言数据中的数值类型都是有符号(正负号)的，在贮存数值类型的数据时，其最高位用来表示数据的正负号。</li><li>简单类型的变量被声明时，存储空间也同时被分配。该贮存空间只占用一个单一贮存单元。对简单类型变量访问则直接可以得到它的数据。</li><li>引用类型声明变量时，是==不会==为变量(即对象)分配存储空间。它们声明的变量不是数据本身，而是数据的引用(reference)，需用new运算符来为引用类型的变量分配贮存空间，在运行时动态的分配内存大小 .例如:==数组==</li><li>整型类型和boolean类型之间不能相互转换   </li><li>switch所用的表达式为int类型相容的数据表达式，它可以是byte、short、char或者int类型的值，特别要指出的是不能是布尔型的值。</li><li>continue的作用与break类似,主要用于循环,所不同的是break会结束程序块的执行,而continue只会结束其之后程序块的语句,并跳回循环程序块的开头继续下一个循环,而不是离开循环  </li><li>方法中引用类型形参改变实参也会改变(引用类型变量指向的是内存地址,形参和实参指向的是同一内存地址.所以方法对引用型变量的改变会保存下来.</li></ol><h2 id="第四章-面向对象-上"><a href="#第四章-面向对象-上" class="headerlink" title="第四章 面向对象(上)"></a>第四章 面向对象(上)</h2><p>类中定义:成员变量;方法中定义:局部变量。同名变量，方法调用的是==局部变量==。——为避免该情形，提供了==this==关键字。</p><hr><h3 id="This关键字"><a href="#This关键字" class="headerlink" title="This关键字"></a>This关键字</h3><blockquote><p>表示当前对象，指向调用的对象本身（成员变量、成员方法）</p></blockquote><p><img src="https://s2.loli.net/2022/01/15/8Mkq7I26APpHFeE.png" alt="1639315871653.png"></p><blockquote><p>println(this)与println(p)输出的是堆地址；</p><p>相等</p><p>不相等</p></blockquote><h4 id="This的三种用法："><a href="#This的三种用法：" class="headerlink" title="This的三种用法："></a>This的三种用法：</h4><ol><li>使用This调用类中属性（常用于带参构造方法中）</li><li>调用成员方法</li><li>调用构造方法：this([实参列表])</li></ol><p>在构造方法中，使用this调用构造方法的语句==必须位于首行==，==且只能出现一次==</p><p>this调用构造方法时，一定要留一个出口，即至少存在一个构造方法不使用this调用其他构造方法。</p><hr><p>声明一个引用变量：==变量名在栈内存中==（如下图,p1,p2）</p><p>new一个对象：==为对象在堆中分配内存空间==</p><p>一个对象能够被多个变量所引用</p><p><img src="https://s2.loli.net/2022/01/15/v3WAGUs7zucw29Y.png" alt="1639314467617.png"></p><h3 id="垃圾回收"><a href="#垃圾回收" class="headerlink" title="垃圾回收"></a>垃圾回收</h3><blockquote><p>动态存储管理技术，由Java虚拟机自动回收垃圾对象所占的内存空间</p><hr></blockquote><p>在setXxx()方法中，如果对属性有条件制约，那么调用set方法输入被过滤范围内的数值时，原属性仍为初始化值（String:null，int:0）</p><p>类未定义构造方法时，系统会自动提供一个空参构造器，但自己定义构造方法后，<strong>系统==不会==再提供空参构造器。</strong></p><p>重载：多个构造方法，但是参数列表不同。</p><h3 id="static关键字"><a href="#static关键字" class="headerlink" title="static关键字"></a>static关键字</h3><blockquote><p>使用static关键字修饰的成员变量称为静态变量或类变量，它被类的所有对象共享，可以通过==类名==直接访问。</p></blockquote><p>未使用static修饰的变量为实例变量，属于具体对象独有，只能通过引用变量访问。</p><p><img src="https://s2.loli.net/2022/01/15/9BFX7S54nwWCxhl.png" alt="1639317286268.png"></p><p>输出：1（初始化为0）</p><p><img src="https://s2.loli.net/2022/01/15/EtQXZU3jVOFDb2W.png" alt="1639317455240.png"></p><p>输出：5</p><p><strong>注：static关键字在修饰变量的时候只能修饰成员变量，==不能修饰方法中的局部变量==</strong></p><blockquote><p>使用static修饰的成员方法，称为静态方法，无需创建类的实例（对象）就可以调用静态方法，其可以通过类名调用。</p></blockquote><p>静态方法==只能访问类的静态成员（静态变量、静态方法）==，不能访问类的实例成员。因为实例成员属于对象，要创建对象才能访问。</p><h3 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h3><blockquote><p>是外部类的一个成员，内部类可以访问外部类的任何成员（包括私有成员:外部类名.this.外部类私有成员变量），外部类不能直接访问内部类成员。</p><p>可为静态，可以用Protect和private修饰（外部类不能，只能public和默认）</p><p>经Java编译器编译后生成的外部类与内部类是独立的</p></blockquote><p>在外部类中访问内部类需要==创建内部类的对象==使用内部类的对象访问其中成员。</p><p>若在外部类==外==访问内部类，则需要通过外部类对象去创建内部类对象</p><p><code>外部类名.内部类名 引用变量名=new 外部类名().内部类名()</code></p><h2 id="第五章-面向对象（下）"><a href="#第五章-面向对象（下）" class="headerlink" title="第五章 面向对象（下）"></a>第五章 面向对象（下）</h2><h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><p>方法重写：子类重写的方法不能拥有比父类方法更加严格的访问权限。</p><p>重载：在同一个类中，方法名相同，但参数个数或参数类型不同</p><p>重写：子类与父类之间，方法名、返回值类型和参数列表相同。</p><p>子类中访问父类里被重写的方法：super</p><p>在一个构造方法中调用重载的另一个构造方法使用关键字：this；在子类构造方法中调用父类构造方法使用关键字supper（同样要位于构造方法第一行）</p><p>子类中如果没有显式的调用父类的构造方法，将自动调用父类的空参构造方法（若父类没有空参构造方法，则会报错）</p><h3 id="final关键字"><a href="#final关键字" class="headerlink" title="final关键字"></a>final关键字</h3><blockquote><p>用它修饰的类、方法、变量不可以修改：类不能被继承；方法不能被子类重写；变量为常量，初始化后不能再修改。</p></blockquote><p>Java虚拟机不会为final修饰的变量默认初始化——==用final修饰成员变量时，需要在声明时立即初始化，或在构造方法中初始化==</p><p>可以修饰引用变量：表示只能是中引用一个对象，但对象的内容可以更改。</p><h3 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h3><blockquote><p>抽象方法：不含方法体的方法。</p><p>包含抽象方法的类==必须是抽象类==，抽象类可以==不包含任何抽象方法==</p></blockquote><p>抽象类不可以实例化（不能用new创建对象）——必须通过子类继承抽象类去实现抽象方法。(具体子类==必须实现抽象父类中的所有方法==,否则子类必须声明为抽象类.</p><p><strong>抽象方法</strong>（不是抽象类!注意区分）不能用static（可通过类名访问）、final（不能重写）、private（==子类不能访问带private的抽象方法==）关键字修饰。</p><p><strong>注：子类并==不是==能够继承父类的所有属性和方法，子类只能够继承父类的非私有成员。</strong></p><p>抽象类可以定义<strong>构造方法</strong>与成员变量！！！——如果抽象类有构造方法（构造方法允许有方法体），则子类的构造方法中必须先对抽象类进行构造【supper(参数列表)】==子类构造时会默认调用父类中无参构造方法==。</p><h3 id="接口（interface"><a href="#接口（interface" class="headerlink" title="接口（interface"></a>接口（interface</h3><p><strong>变量默认为public static final,方法默认为public abstract。</strong></p><p>implements实现接口（允许==多个==</p><table><thead><tr><th>区别点</th><th>接口</th><th>抽象类</th></tr></thead><tbody><tr><td>含义</td><td>接口通常用于描述一个类的外围能力，而不是核心特征</td><td>抽象类定义了他的子类的核心特征。</td></tr><tr><td>方法</td><td>接口只提供方法声明</td><td>抽象类可以提供完整方法（==抽象类不一定含有抽象方法==）、默认构造方法以及用于覆盖的方法声明。</td></tr><tr><td>变量</td><td>只包含public static final常量，必须在声明时初始化</td><td>可以包含实例变量和静态变量</td></tr><tr><td>多重继承</td><td>一个类可以继承多个接口</td><td>一个类只能继承一个抽象类</td></tr><tr><td>实现类</td><td>类可以实现多个接口</td><td>类只从抽象类派生,必须重写</td></tr></tbody></table><h3 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h3><blockquote><p>同一操作作用于不同的对象可以有不同的解释.</p></blockquote><p><img src="https://s2.loli.net/2022/01/15/FXpT6uAJDz8d4om.png" alt="1639491096792.png"></p><p>方法的实现是由变量的==实际类型==决定的。</p><p>多态体现的是==向上转型==,也称隐式转换。</p><p>向下转型必须强制转换：</p><p><code>Person p=new Child();//向上转型</code></p><p><code>Parent o =(Parent)p;//向下转型</code></p><p><img src="https://s2.loli.net/2022/01/15/wR5ubgjCsoXJSkG.png" alt="1639491670509.png"></p><p><img src="https://s2.loli.net/2022/01/15/F9m6yajg7AZ8MHQ.png" alt="1639491747777.png"></p><p><img src="https://s2.loli.net/2022/01/15/IKCfAeJlaY8QkHw.png" alt="1639492138248.png"></p><p>equals类默认比较的是引用变量地址（==也是）；String类中的equals被重写为比较两字符串内容是否相等。</p><h3 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h3><h4 id="线程的安全性问题"><a href="#线程的安全性问题" class="headerlink" title="==线程的安全性问题=="></a>==线程的安全性问题==</h4><p>1.同步代码块</p><h2 id="IO流"><a href="#IO流" class="headerlink" title="IO流"></a>IO流</h2><h3 id="FileInputStream"><a href="#FileInputStream" class="headerlink" title="FileInputStream"></a>FileInputStream</h3><p>finally不能直接访问try中的内容,为防止程序中断后,流无法释放占用资源,==一定要将close方法写在finally中==,流要定义在==try外面==</p><p><img src="https://s2.loli.net/2022/01/15/YThykrqg1wbZ5WK.png" alt="1641101856200.png"></p>]]></content>
      
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode No.7</title>
      <link href="posts/c5bc31ac.html"/>
      <url>posts/c5bc31ac.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>[TOC]</p><h1 id="LeetCode题解（7-整数反转）"><a href="#LeetCode题解（7-整数反转）" class="headerlink" title="LeetCode题解（7.整数反转）"></a>LeetCode题解（7.整数反转）</h1><h2 id="题面"><a href="#题面" class="headerlink" title="题面"></a>题面</h2><blockquote><p>给你一个 32 位的有符号整数 x ，返回将 x 中的数字部分反转后的结果。</p><p>如果反转后整数超过 32 位的有符号整数的范围 [−231,  231 − 1] ，就返回 0。<br>假设环境不允许存储 64 位整数（有符号或无符号）。</p><p>示例 1：</p><p>输入：x = 123<br>输出：321</p><p>示例 2：</p><p>输入：x = -123<br>输出：-321</p><p>示例 3：</p><p>输入：x = 120<br>输出：21</p><p>示例 4：</p><p>输入：x = 0<br>输出：0</p><p>提示：</p><p> -231 &lt;= x &lt;= 231 - 1</p></blockquote><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>整数反转算是烂大街的（不是）考题了，其实看到反转第一反应是栈……但是对付整数来讲略微小题大做。</p><p>最无脑的反转方法就是x/10,x%10,x%100……得到x每一位上的数字然后再乘回去，从这种无脑的思想中其实可以总结出一个公式：result = result*10+x%10;x=x/10; 构成循环，循环的终止条件自然就是x==0，这种情况，while最合适了。</p><p>这里记录一下我犯过的愚蠢错误：</p><ol><li>倒在单词拼写上的女人：while我再也不会拼错啦</li><li>x/10和x%10:前者是得到去除个位后的数字，后者是取当前个位数字（老是搞混，呜呜</li></ol><p>但是！这道题最膈应人的地方并不是如何把整数反转（因为它实在是太简单了</p><hr><p>这道题的重头应该在于==特殊情况的输出如何进行判断==</p><p>如题，我们最后的结果result在超过一定范围后要输出0，所以显然我们要对result取值进行判断，但是==假设环境不允许存储 64 位整数（有符号或无符号）。==</p><p>？？？</p><p>这怎么搞</p><p>环境不允许存储64位整数意味着无法写该范围————怎么处理？</p><p>这时候想到了long 64位，如果将64位long强转为int也相等……OK</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">reverse</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">long</span> result <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">while</span><span class="token punctuation">(</span>x<span class="token operator">!=</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            result<span class="token operator">=</span>result<span class="token operator">*</span><span class="token number">10</span><span class="token operator">+</span>x<span class="token operator">%</span><span class="token number">10</span><span class="token punctuation">;</span>            x<span class="token operator">=</span>x<span class="token operator">/</span><span class="token number">10</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span>result <span class="token operator">==</span> result<span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span>result<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">else</span>            <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://s2.loli.net/2022/01/15/trMdhYxR1fpwzL4.png" alt="1638237528394.png"></p>]]></content>
      
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
