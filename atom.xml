<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Ysh-Lr&#39;s Blog</title>
  
  <subtitle>Ysh-Lrの博客</subtitle>
  <link href="https://ysh-lr.github.io/atom.xml" rel="self"/>
  
  <link href="https://ysh-lr.github.io/"/>
  <updated>2022-01-14T13:30:15.876Z</updated>
  <id>https://ysh-lr.github.io/</id>
  
  <author>
    <name>Ysh-Lr</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>操作系统学习笔记(一)</title>
    <link href="https://ysh-lr.github.io/posts/392e0872.html"/>
    <id>https://ysh-lr.github.io/posts/392e0872.html</id>
    <published>2022-01-14T11:51:44.000Z</published>
    <updated>2022-01-14T13:30:15.876Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="计算机操作系统-一"><a href="#计算机操作系统-一" class="headerlink" title="计算机操作系统(一)"></a>计算机操作系统(一)</h1><blockquote><p>操作系统是配置在计算机硬件上的第一层软件,是对硬件系统的首次扩充,其主要作用是管理好这些设备,提高它们的利用率和系统的吞吐量,并为用户和应用程序提供一个简单的接口,便于用户使用。</p></blockquote><h3 id="操作系统的作用"><a href="#操作系统的作用" class="headerlink" title="操作系统的作用"></a>操作系统的作用</h3><ol><li>作为用户与计算机硬件系统之间的接口；</li><li>作为计算机系统资源的管理者；</li><li>实现了对计算机资源的抽象；</li></ol><p>43321112334</p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    
    <category term="操作系统" scheme="https://ysh-lr.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>机器学习Day1</title>
    <link href="https://ysh-lr.github.io/posts/8625e497.html"/>
    <id>https://ysh-lr.github.io/posts/8625e497.html</id>
    <published>2022-01-14T01:05:36.000Z</published>
    <updated>2022-01-14T01:06:55.040Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>[TOC]</p><h1 id="机器学习-Day-1"><a href="#机器学习-Day-1" class="headerlink" title="机器学习 Day.1"></a>机器学习 Day.1</h1><blockquote><p>一般地，令D = {x,x2….x.m}表示包含m个示例的数据集，每个示例由d个属性描述,则每个示例Xi= (xi1;xi2;……;xid) 是d维样本空间X中的一个向量, xi∈x,其中xij是xi在第j个属性上的取值(例如上述第3个西瓜在第2个属性上的值是“硬挺”), d称为样本xi的“维数”(dimensionality).</p></blockquote><h2 id="基础概念"><a href="#基础概念" class="headerlink" title="基础概念"></a>基础概念</h2><ul><li>（属性1 = 取值，属性2 = 取值，……，属性3=取值）——一个示例</li><li>{示例1，示例2，……，示例3}——数据集</li></ul><p>每条示例中所有的属性分别看作一根坐标轴张成==属性空间/样本空间==，则可以把一个示例称为==特征向量==</p><pre class="line-numbers language-mermaid" data-language="mermaid"><code class="language-mermaid">graph LRA[预测任务] --&gt;Z(监督学习)A --&gt;Y(无监督学习)Y--&gt;X(聚类)Z --&gt;B(离散型)  B --&gt; C(分类)    C --&gt;|仅涉及两个类别|F(二分类)    F --&gt;M(y = -1,+1)    C --&gt;|涉及多个类别|G(多分类)    G --&gt;L(y的绝对值&gt;2)  Z --&gt;D(连续型)  D --&gt;E(回归)    E --&gt;N(y=R)  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>泛化能力：学得模型适用于新样本的能力。</li><li>假设空间规模大小：搜索目标是找到能够将训练集中的瓜判断正确的假设。假设的表示一旦确定，假设空间及规模大小也就确定了：（属性1的表示个数<em>属性2的……</em>属性n的表示个数==+1==）</li></ul><p>注：在考虑取值的时候，要考虑==该属性不影响结果==（用通配符*表示）、==不存在要求结果==（输出结果为空）两种容易忽略的情况。</p><ul><li><p>版本空间：根据假设的表示得到假设空间，剔除与样本集中正例（某事发生）不一致的假设向量和与负例一致的假设向量后剩余向量构成版本空间。</p><p>注意：含通配符的假设向量可能会和负例一致，一定要谨慎！不要多/少</p></li><li><p>偏好：1.尽可能特殊（适用情况尽可能少）；2.尽可能一般（适用情况尽可能多）；……</p></li></ul><blockquote><p><code>怎么判断是一般还是特殊？</code></p><p>​    <code>数据集中符合新样本属性的各类示例输出结果中多的为一般，少的为特殊。</code></p></blockquote><p>==引导算法确立“正确的”偏好的原则==</p><p>“奥卡姆剃刀”：若有多个假设与观察一致，则选最简单的那个</p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    
    <category term="西瓜书 笔记" scheme="https://ysh-lr.github.io/tags/%E8%A5%BF%E7%93%9C%E4%B9%A6-%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>Java复习细节拾遗</title>
    <link href="https://ysh-lr.github.io/posts/1486b1bb.html"/>
    <id>https://ysh-lr.github.io/posts/1486b1bb.html</id>
    <published>2022-01-13T13:43:03.000Z</published>
    <updated>2022-01-15T02:14:58.710Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>[TOC]</p><h1 id="Java复习-细节拾遗"><a href="#Java复习-细节拾遗" class="headerlink" title="Java复习(细节拾遗)"></a>Java复习(细节拾遗)</h1><h2 id="前三章的一点点小知识"><a href="#前三章的一点点小知识" class="headerlink" title="前三章的一点点小知识"></a>前三章的一点点小知识</h2><p><img src="https://s2.loli.net/2022/01/15/uC1xMbDcgjV5dJA.png" alt="1640868328646.png"></p><ol><li>Java语言数据中的数值类型都是有符号(正负号)的，在贮存数值类型的数据时，其最高位用来表示数据的正负号。</li><li>简单类型的变量被声明时，存储空间也同时被分配。该贮存空间只占用一个单一贮存单元。对简单类型变量访问则直接可以得到它的数据。</li><li>引用类型声明变量时，是==不会==为变量(即对象)分配存储空间。它们声明的变量不是数据本身，而是数据的引用(reference)，需用new运算符来为引用类型的变量分配贮存空间，在运行时动态的分配内存大小 .例如:==数组==</li><li>整型类型和boolean类型之间不能相互转换   </li><li>switch所用的表达式为int类型相容的数据表达式，它可以是byte、short、char或者int类型的值，特别要指出的是不能是布尔型的值。</li><li>continue的作用与break类似,主要用于循环,所不同的是break会结束程序块的执行,而continue只会结束其之后程序块的语句,并跳回循环程序块的开头继续下一个循环,而不是离开循环  </li><li>方法中引用类型形参改变实参也会改变(引用类型变量指向的是内存地址,形参和实参指向的是同一内存地址.所以方法对引用型变量的改变会保存下来.</li></ol><h2 id="第四章-面向对象-上"><a href="#第四章-面向对象-上" class="headerlink" title="第四章 面向对象(上)"></a>第四章 面向对象(上)</h2><p>类中定义:成员变量;方法中定义:局部变量。同名变量，方法调用的是==局部变量==。——为避免该情形，提供了==this==关键字。</p><hr><h3 id="This关键字"><a href="#This关键字" class="headerlink" title="This关键字"></a>This关键字</h3><blockquote><p>表示当前对象，指向调用的对象本身（成员变量、成员方法）</p></blockquote><p><img src="https://s2.loli.net/2022/01/15/8Mkq7I26APpHFeE.png" alt="1639315871653.png"></p><blockquote><p>println(this)与println(p)输出的是堆地址；</p><p>相等</p><p>不相等</p></blockquote><h4 id="This的三种用法："><a href="#This的三种用法：" class="headerlink" title="This的三种用法："></a>This的三种用法：</h4><ol><li>使用This调用类中属性（常用于带参构造方法中）</li><li>调用成员方法</li><li>调用构造方法：this([实参列表])</li></ol><p>在构造方法中，使用this调用构造方法的语句==必须位于首行==，==且只能出现一次==</p><p>this调用构造方法时，一定要留一个出口，即至少存在一个构造方法不使用this调用其他构造方法。</p><hr><p>声明一个引用变量：==变量名在栈内存中==（如下图,p1,p2）</p><p>new一个对象：==为对象在堆中分配内存空间==</p><p>一个对象能够被多个变量所引用</p><p><img src="https://s2.loli.net/2022/01/15/v3WAGUs7zucw29Y.png" alt="1639314467617.png"></p><h3 id="垃圾回收"><a href="#垃圾回收" class="headerlink" title="垃圾回收"></a>垃圾回收</h3><blockquote><p>动态存储管理技术，由Java虚拟机自动回收垃圾对象所占的内存空间</p><hr></blockquote><p>在setXxx()方法中，如果对属性有条件制约，那么调用set方法输入被过滤范围内的数值时，原属性仍为初始化值（String:null，int:0）</p><p>类未定义构造方法时，系统会自动提供一个空参构造器，但自己定义构造方法后，<strong>系统==不会==再提供空参构造器。</strong></p><p>重载：多个构造方法，但是参数列表不同。</p><h3 id="static关键字"><a href="#static关键字" class="headerlink" title="static关键字"></a>static关键字</h3><blockquote><p>使用static关键字修饰的成员变量称为静态变量或类变量，它被类的所有对象共享，可以通过==类名==直接访问。</p></blockquote><p>未使用static修饰的变量为实例变量，属于具体对象独有，只能通过引用变量访问。</p><p><img src="https://s2.loli.net/2022/01/15/9BFX7S54nwWCxhl.png" alt="1639317286268.png"></p><p>输出：1（初始化为0）</p><p><img src="https://s2.loli.net/2022/01/15/EtQXZU3jVOFDb2W.png" alt="1639317455240.png"></p><p>输出：5</p><p><strong>注：static关键字在修饰变量的时候只能修饰成员变量，==不能修饰方法中的局部变量==</strong></p><blockquote><p>使用static修饰的成员方法，称为静态方法，无需创建类的实例（对象）就可以调用静态方法，其可以通过类名调用。</p></blockquote><p>静态方法==只能访问类的静态成员（静态变量、静态方法）==，不能访问类的实例成员。因为实例成员属于对象，要创建对象才能访问。</p><h3 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h3><blockquote><p>是外部类的一个成员，内部类可以访问外部类的任何成员（包括私有成员:外部类名.this.外部类私有成员变量），外部类不能直接访问内部类成员。</p><p>可为静态，可以用Protect和private修饰（外部类不能，只能public和默认）</p><p>经Java编译器编译后生成的外部类与内部类是独立的</p></blockquote><p>在外部类中访问内部类需要==创建内部类的对象==使用内部类的对象访问其中成员。</p><p>若在外部类==外==访问内部类，则需要通过外部类对象去创建内部类对象</p><p><code>外部类名.内部类名 引用变量名=new 外部类名().内部类名()</code></p><h2 id="第五章-面向对象（下）"><a href="#第五章-面向对象（下）" class="headerlink" title="第五章 面向对象（下）"></a>第五章 面向对象（下）</h2><h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><p>方法重写：子类重写的方法不能拥有比父类方法更加严格的访问权限。</p><p>重载：在同一个类中，方法名相同，但参数个数或参数类型不同</p><p>重写：子类与父类之间，方法名、返回值类型和参数列表相同。</p><p>子类中访问父类里被重写的方法：super</p><p>在一个构造方法中调用重载的另一个构造方法使用关键字：this；在子类构造方法中调用父类构造方法使用关键字supper（同样要位于构造方法第一行）</p><p>子类中如果没有显式的调用父类的构造方法，将自动调用父类的空参构造方法（若父类没有空参构造方法，则会报错）</p><h3 id="final关键字"><a href="#final关键字" class="headerlink" title="final关键字"></a>final关键字</h3><blockquote><p>用它修饰的类、方法、变量不可以修改：类不能被继承；方法不能被子类重写；变量为常量，初始化后不能再修改。</p></blockquote><p>Java虚拟机不会为final修饰的变量默认初始化——==用final修饰成员变量时，需要在声明时立即初始化，或在构造方法中初始化==</p><p>可以修饰引用变量：表示只能是中引用一个对象，但对象的内容可以更改。</p><h3 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h3><blockquote><p>抽象方法：不含方法体的方法。</p><p>包含抽象方法的类==必须是抽象类==，抽象类可以==不包含任何抽象方法==</p></blockquote><p>抽象类不可以实例化（不能用new创建对象）——必须通过子类继承抽象类去实现抽象方法。(具体子类==必须实现抽象父类中的所有方法==,否则子类必须声明为抽象类.</p><p><strong>抽象方法</strong>（不是抽象类!注意区分）不能用static（可通过类名访问）、final（不能重写）、private（==子类不能访问带private的抽象方法==）关键字修饰。</p><p><strong>注：子类并==不是==能够继承父类的所有属性和方法，子类只能够继承父类的非私有成员。</strong></p><p>抽象类可以定义<strong>构造方法</strong>与成员变量！！！——如果抽象类有构造方法（构造方法允许有方法体），则子类的构造方法中必须先对抽象类进行构造【supper(参数列表)】==子类构造时会默认调用父类中无参构造方法==。</p><h3 id="接口（interface"><a href="#接口（interface" class="headerlink" title="接口（interface"></a>接口（interface</h3><p><strong>变量默认为public static final,方法默认为public abstract。</strong></p><p>implements实现接口（允许==多个==</p><table><thead><tr><th>区别点</th><th>接口</th><th>抽象类</th></tr></thead><tbody><tr><td>含义</td><td>接口通常用于描述一个类的外围能力，而不是核心特征</td><td>抽象类定义了他的子类的核心特征。</td></tr><tr><td>方法</td><td>接口只提供方法声明</td><td>抽象类可以提供完整方法（==抽象类不一定含有抽象方法==）、默认构造方法以及用于覆盖的方法声明。</td></tr><tr><td>变量</td><td>只包含public static final常量，必须在声明时初始化</td><td>可以包含实例变量和静态变量</td></tr><tr><td>多重继承</td><td>一个类可以继承多个接口</td><td>一个类只能继承一个抽象类</td></tr><tr><td>实现类</td><td>类可以实现多个接口</td><td>类只从抽象类派生,必须重写</td></tr></tbody></table><h3 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h3><blockquote><p>同一操作作用于不同的对象可以有不同的解释.</p></blockquote><p><img src="https://s2.loli.net/2022/01/15/FXpT6uAJDz8d4om.png" alt="1639491096792.png"></p><p>方法的实现是由变量的==实际类型==决定的。</p><p>多态体现的是==向上转型==,也称隐式转换。</p><p>向下转型必须强制转换：</p><p><code>Person p=new Child();//向上转型</code></p><p><code>Parent o =(Parent)p;//向下转型</code></p><p><img src="https://s2.loli.net/2022/01/15/wR5ubgjCsoXJSkG.png" alt="1639491670509.png"></p><p><img src="https://s2.loli.net/2022/01/15/F9m6yajg7AZ8MHQ.png" alt="1639491747777.png"></p><p><img src="https://s2.loli.net/2022/01/15/IKCfAeJlaY8QkHw.png" alt="1639492138248.png"></p><p>equals类默认比较的是引用变量地址（==也是）；String类中的equals被重写为比较两字符串内容是否相等。</p><h3 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h3><h4 id="线程的安全性问题"><a href="#线程的安全性问题" class="headerlink" title="==线程的安全性问题=="></a>==线程的安全性问题==</h4><p>1.同步代码块</p><h2 id="IO流"><a href="#IO流" class="headerlink" title="IO流"></a>IO流</h2><h3 id="FileInputStream"><a href="#FileInputStream" class="headerlink" title="FileInputStream"></a>FileInputStream</h3><p>finally不能直接访问try中的内容,为防止程序中断后,流无法释放占用资源,==一定要将close方法写在finally中==,流要定义在==try外面==</p><p><img src="https://s2.loli.net/2022/01/15/YThykrqg1wbZ5WK.png" alt="1641101856200.png"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    
    <category term="java" scheme="https://ysh-lr.github.io/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode No.7</title>
    <link href="https://ysh-lr.github.io/posts/c5bc31ac.html"/>
    <id>https://ysh-lr.github.io/posts/c5bc31ac.html</id>
    <published>2022-01-13T13:30:26.000Z</published>
    <updated>2022-01-15T02:08:09.697Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>[TOC]</p><h1 id="LeetCode题解（7-整数反转）"><a href="#LeetCode题解（7-整数反转）" class="headerlink" title="LeetCode题解（7.整数反转）"></a>LeetCode题解（7.整数反转）</h1><h2 id="题面"><a href="#题面" class="headerlink" title="题面"></a>题面</h2><blockquote><p>给你一个 32 位的有符号整数 x ，返回将 x 中的数字部分反转后的结果。</p><p>如果反转后整数超过 32 位的有符号整数的范围 [−231,  231 − 1] ，就返回 0。<br>假设环境不允许存储 64 位整数（有符号或无符号）。</p><p>示例 1：</p><p>输入：x = 123<br>输出：321</p><p>示例 2：</p><p>输入：x = -123<br>输出：-321</p><p>示例 3：</p><p>输入：x = 120<br>输出：21</p><p>示例 4：</p><p>输入：x = 0<br>输出：0</p><p>提示：</p><p> -231 &lt;= x &lt;= 231 - 1</p></blockquote><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>整数反转算是烂大街的（不是）考题了，其实看到反转第一反应是栈……但是对付整数来讲略微小题大做。</p><p>最无脑的反转方法就是x/10,x%10,x%100……得到x每一位上的数字然后再乘回去，从这种无脑的思想中其实可以总结出一个公式：result = result*10+x%10;x=x/10; 构成循环，循环的终止条件自然就是x==0，这种情况，while最合适了。</p><p>这里记录一下我犯过的愚蠢错误：</p><ol><li>倒在单词拼写上的女人：while我再也不会拼错啦</li><li>x/10和x%10:前者是得到去除个位后的数字，后者是取当前个位数字（老是搞混，呜呜</li></ol><p>但是！这道题最膈应人的地方并不是如何把整数反转（因为它实在是太简单了</p><hr><p>这道题的重头应该在于==特殊情况的输出如何进行判断==</p><p>如题，我们最后的结果result在超过一定范围后要输出0，所以显然我们要对result取值进行判断，但是==假设环境不允许存储 64 位整数（有符号或无符号）。==</p><p>？？？</p><p>这怎么搞</p><p>环境不允许存储64位整数意味着无法写该范围————怎么处理？</p><p>这时候想到了long 64位，如果将64位long强转为int也相等……OK</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">reverse</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">long</span> result <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">while</span><span class="token punctuation">(</span>x<span class="token operator">!=</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            result<span class="token operator">=</span>result<span class="token operator">*</span><span class="token number">10</span><span class="token operator">+</span>x<span class="token operator">%</span><span class="token number">10</span><span class="token punctuation">;</span>            x<span class="token operator">=</span>x<span class="token operator">/</span><span class="token number">10</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span>result <span class="token operator">==</span> result<span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span>result<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">else</span>            <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://s2.loli.net/2022/01/15/trMdhYxR1fpwzL4.png" alt="1638237528394.png"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    
    <category term="LeetCode" scheme="https://ysh-lr.github.io/tags/LeetCode/"/>
    
  </entry>
  
</feed>
