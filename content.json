{"meta":{"title":"Ysh-Lr's Blog","subtitle":"Ysh-Lrの博客","description":"本科二年级 | 软件工程 | 系统与技术","author":"Ysh-Lr","url":"https://ysh-lr.github.io","root":"/"},"pages":[{"title":"放松一下","date":"2019-08-10T08:41:10.000Z","updated":"2022-01-13T09:37:49.593Z","comments":true,"path":"List/index.html","permalink":"https://ysh-lr.github.io/List/index.html","excerpt":"","text":"影音资源共享"},{"title":"","date":"2022-01-13T09:51:49.590Z","updated":"2022-01-13T09:37:50.007Z","comments":true,"path":"google1xxxxxxx0.html","permalink":"https://ysh-lr.github.io/google1xxxxxxx0.html","excerpt":"","text":"google-site-verification: google110e5e5e14c8dcf0.html"},{"title":"404","date":"2019-08-10T08:41:10.000Z","updated":"2022-01-13T09:37:49.531Z","comments":true,"path":"404.html","permalink":"https://ysh-lr.github.io/404.html","excerpt":"","text":""},{"title":"","date":"2022-01-13T09:51:49.585Z","updated":"2022-01-13T09:37:50.000Z","comments":true,"path":"baidu_verify_xxxxxxx.html","permalink":"https://ysh-lr.github.io/baidu_verify_xxxxxxx.html","excerpt":"","text":"wvlc3L96QK"},{"title":"archives","date":"2019-10-24T16:00:00.000Z","updated":"2022-01-13T09:37:50.000Z","comments":true,"path":"archives/index.html","permalink":"https://ysh-lr.github.io/archives/index.html","excerpt":"","text":""},{"title":"about","date":"2019-10-24T16:00:00.000Z","updated":"2022-01-13T09:37:49.996Z","comments":true,"path":"about/index.html","permalink":"https://ysh-lr.github.io/about/index.html","excerpt":"","text":""},{"title":"categories","date":"2019-10-24T16:00:00.000Z","updated":"2022-01-13T09:37:50.000Z","comments":true,"path":"categories/index.html","permalink":"https://ysh-lr.github.io/categories/index.html","excerpt":"","text":""},{"title":"统计","date":"2020-10-31T02:11:28.000Z","updated":"2022-01-13T09:37:50.004Z","comments":true,"path":"census/index.html","permalink":"https://ysh-lr.github.io/census/index.html","excerpt":"","text":""},{"title":"友链","date":"2019-07-19T08:42:10.000Z","updated":"2022-01-13T09:37:50.006Z","comments":true,"path":"friends/index.html","permalink":"https://ysh-lr.github.io/friends/index.html","excerpt":"","text":""},{"title":"留言板","date":"2022-01-13T10:19:00.000Z","updated":"2022-01-13T10:20:43.969Z","comments":true,"path":"contact/index.html","permalink":"https://ysh-lr.github.io/contact/index.html","excerpt":"","text":"畅所欲言 在这里可以留下你的足迹，欢迎在下方留言，欢迎交换友链，一起交流学习！ 友链 Ysh-Lr de 友链信息 博客名称: Ysh-Lrの博客 博客网址: Hexo (ysh-lr.github.io) 博客头像: https://s1.ax1x.com/2020/05/17/YRWsYT.png 博客介绍: 去出发,去遇见"},{"title":"资源分享","date":"2019-07-19T08:40:27.000Z","updated":"2022-01-13T09:37:50.008Z","comments":true,"path":"resource/index.html","permalink":"https://ysh-lr.github.io/resource/index.html","excerpt":"","text":""},{"title":"tags","date":"2019-07-19T08:40:27.000Z","updated":"2022-01-13T09:37:50.010Z","comments":true,"path":"tags/index.html","permalink":"https://ysh-lr.github.io/tags/index.html","excerpt":"","text":""},{"title":"相册","date":"2022-01-13T09:37:49.558Z","updated":"2022-01-13T09:37:49.558Z","comments":true,"path":"List/galleries/index.html","permalink":"https://ysh-lr.github.io/List/galleries/index.html","excerpt":"","text":""},{"title":"听听音乐","date":"2019-07-19T08:40:27.000Z","updated":"2022-01-13T09:37:49.601Z","comments":true,"path":"List/tools/index.html","permalink":"https://ysh-lr.github.io/List/tools/index.html","excerpt":"","text":""},{"title":"听听音乐","date":"2019-07-19T08:40:27.000Z","updated":"2022-01-13T09:37:49.593Z","comments":true,"path":"List/music/index.html","permalink":"https://ysh-lr.github.io/List/music/index.html","excerpt":"","text":""},{"title":"视频","date":"2019-08-10T08:41:10.000Z","updated":"2022-01-13T09:37:49.593Z","comments":true,"path":"List/movies/index.html","permalink":"https://ysh-lr.github.io/List/movies/index.html","excerpt":"","text":""},{"title":"乖巧小狗","date":"2022-01-13T09:37:49.566Z","updated":"2022-01-13T09:37:49.566Z","comments":true,"path":"List/galleries/乖巧小狗/index.html","permalink":"https://ysh-lr.github.io/List/galleries/%E4%B9%96%E5%B7%A7%E5%B0%8F%E7%8B%97/index.html","excerpt":"","text":""},{"title":"动漫插画","date":"2022-01-13T09:37:49.573Z","updated":"2022-01-13T09:37:49.573Z","comments":true,"path":"List/galleries/动漫插画/index.html","permalink":"https://ysh-lr.github.io/List/galleries/%E5%8A%A8%E6%BC%AB%E6%8F%92%E7%94%BB/index.html","excerpt":"","text":""},{"title":"呆萌猫咪","date":"2022-01-13T09:37:49.576Z","updated":"2022-01-13T09:37:49.576Z","comments":true,"path":"List/galleries/呆萌猫咪/index.html","permalink":"https://ysh-lr.github.io/List/galleries/%E5%91%86%E8%90%8C%E7%8C%AB%E5%92%AA/index.html","excerpt":"","text":""},{"title":"二次元风","date":"2022-01-13T09:37:49.568Z","updated":"2022-01-13T09:37:49.568Z","comments":true,"path":"List/galleries/二次元风/index.html","permalink":"https://ysh-lr.github.io/List/galleries/%E4%BA%8C%E6%AC%A1%E5%85%83%E9%A3%8E/index.html","excerpt":"","text":""},{"title":"动漫风景","date":"2022-01-13T09:37:49.575Z","updated":"2022-01-13T09:37:49.575Z","comments":true,"path":"List/galleries/动漫风景/index.html","permalink":"https://ysh-lr.github.io/List/galleries/%E5%8A%A8%E6%BC%AB%E9%A3%8E%E6%99%AF/index.html","excerpt":"","text":""},{"title":"动漫人物","date":"2022-01-13T09:37:49.568Z","updated":"2022-01-13T09:37:49.568Z","comments":true,"path":"List/galleries/动漫人物/index.html","permalink":"https://ysh-lr.github.io/List/galleries/%E5%8A%A8%E6%BC%AB%E4%BA%BA%E7%89%A9/index.html","excerpt":"","text":""},{"title":"城市风光","date":"2022-01-13T09:37:49.576Z","updated":"2022-01-13T09:37:49.576Z","comments":true,"path":"List/galleries/城市风光/index.html","permalink":"https://ysh-lr.github.io/List/galleries/%E5%9F%8E%E5%B8%82%E9%A3%8E%E5%85%89/index.html","excerpt":"","text":""},{"title":"清新花卉","date":"2022-01-13T09:37:49.584Z","updated":"2022-01-13T09:37:49.584Z","comments":true,"path":"List/galleries/清新花卉/index.html","permalink":"https://ysh-lr.github.io/List/galleries/%E6%B8%85%E6%96%B0%E8%8A%B1%E5%8D%89/index.html","excerpt":"","text":""},{"title":"炫酷跑车","date":"2022-01-13T09:37:49.585Z","updated":"2022-01-13T09:37:49.585Z","comments":true,"path":"List/galleries/炫酷跑车/index.html","permalink":"https://ysh-lr.github.io/List/galleries/%E7%82%AB%E9%85%B7%E8%B7%91%E8%BD%A6/index.html","excerpt":"","text":""},{"title":"璀璨星空","date":"2022-01-13T09:37:49.585Z","updated":"2022-01-13T09:37:49.585Z","comments":true,"path":"List/galleries/璀璨星空/index.html","permalink":"https://ysh-lr.github.io/List/galleries/%E7%92%80%E7%92%A8%E6%98%9F%E7%A9%BA/index.html","excerpt":"","text":""},{"title":"甜美食品","date":"2022-01-13T09:37:49.585Z","updated":"2022-01-13T09:37:49.585Z","comments":true,"path":"List/galleries/甜美食品/index.html","permalink":"https://ysh-lr.github.io/List/galleries/%E7%94%9C%E7%BE%8E%E9%A3%9F%E5%93%81/index.html","excerpt":"","text":""},{"title":"自然风景","date":"2022-01-13T09:37:49.593Z","updated":"2022-01-13T09:37:49.593Z","comments":true,"path":"List/galleries/自然风景/index.html","permalink":"https://ysh-lr.github.io/List/galleries/%E8%87%AA%E7%84%B6%E9%A3%8E%E6%99%AF/index.html","excerpt":"","text":""}],"posts":[{"title":"数据库(X版)","slug":"数据库-1","date":"2022-05-27T12:08:53.000Z","updated":"2022-05-29T07:05:35.479Z","comments":true,"path":"posts/8d2241fe.html","link":"","permalink":"https://ysh-lr.github.io/posts/8d2241fe.html","excerpt":"","text":"数据库乱序复习（X版）unique：列完整性约束——该属性取值独特，即在该表中没有元组的这一属性相同 distinct： 查询时输出去掉重复值 列约束定义主键与表约束定义主键： 列约束定义主键 primary key关键词只能定义单列主键，无法定义复合主键； 表约束定义主键：便于定义复合主键；可命名主键约束 索引：是一种按照关系表中 指定列 的取值顺序组织元组数据存储的数据结构 ——可以加快表中数据的查询访问。 提高数据检索错误 可快速连接关联表 减少分组和排序时间 但会引入额外开销：创建和维护索引、占用额外空间、数据操纵因维护索引带来系统性能开销。 ​ select语句中select子句实现的是投影（选列），where子句实现的是选择（选行） ​ 在group by语句中，可以同时使用where子句和having子句进行分组统计，先使用where子句选择符合条件的元组——&gt;作为分组的对象，然后形成分组，最后应用having条件，筛选分组后的结果进行统计 θ连接运算是从R和S的笛卡尔积中选取R关系在A属性组上的值与 S关系在B属性组上的值满⾜⽐较关系θ的元组集合，组成新的关系。——是笛卡尔积和选择运算组合而成的。 视图:建立在SELECT查询结果集上的。 没有自己的数据——使用存储在基础表中的数据 基础表中的改变会影响视图、视图中的改变同样会影响基础表 只能实现对数据的查询和一定约束的修改与删除 一个数据库不允许有两个视图同名 使用视图的好处：使用视图简化复杂SQL查询操作；使用视图提高数据访问安全性；提供一定程度的数据逻辑独立性；集中展示用户所感兴趣的特定数据 数据库管理 数据库管理（DataBase Management,DBM）指为保证数据库系统的正常运⾏和服务质量，有关⼈员必须进⾏的系统管理。 负责数据库系统管理任务的⼈员 被称为 数 据 库 管 理 员（DBA） DBA进行数据库管理的目标如下： 保障数据库系统正常稳定运行； 充分发挥数据库系统的软硬件处理能力； 确保数据库系统安全和用户数据隐私性； 有效管理数据库系统用户及其角色权限； 解决数据库系统性能优化、系统故障与数据损坏问题； 最大限度地发挥数据库对其所属机构的作用。 内容包括：DBMS运行管理、数据库性能监控、事务并发控制、数据库索引管理、数据库调优、数据库重构、数据库角色管理、数据库用户管理、对象访问权限管理、数据安全管理、数据库备份、数据库故障恢复处理 DBMS的功能①数据库定义：提供了DBA对数据库及其对象进行创建于修改的功能. DBA 是通过DBMS执行DDL ②数据库运行管理：启停控制、多用户环境下事务并发控制、数据库事务管理、访问操作安全性检查、访问操作存取控制、访问操作完整性检查、系统运行日志管理、系统运行性能监控等。 ③数据组织与存储 ④数据库维护 ⑤数据库通信 ，DBMS本⾝还需要通过操作系统的系统调⽤，才能实现对数据 库⽂件的存取访问 事务 指由构成单个逻辑处理单元的 ⼀组数据库访问操作，这些操作的SQL语句被封装在⼀起，它们要么 都被成功执⾏，要么都不被执⾏。 原子性 一致性 隔离性 持续性 并发执行： 改善系统的资源利用率 减少事务执行的平均等待时间 并发事务控制调度器控制哥哥十五的数据读/写操作指令按照特定顺序执行。 结论：在事务并发运行中，只有当事务调度顺序的执行结果与事务串行执行的数据结果一样时，该并发事务调度才能保证数据库的一致性——可串行化调度 锁表机制+并发控制调度器 排他锁（Lock-X）：可以封锁其他事物对共享数据的任何加锁操作，限制其他事物对共享数据的修改、删除、读取操作 共享锁（Lock-S）只封锁其他事务对加锁数据的修改或删除操作，但可以允许其他事务对加锁数据进行共享数据读操作 当⼀个共享数据已经被⼀个事务实施了排他锁后，其他事务不能再对该数据进⾏任何锁定操作，必须等待原有锁定 解除后，本事务才能对共享数据施加锁定。当⼀个共享数据已经被⼀个事务实施了共享锁，其他事务对该数据只能施加共享锁定，不能再添加排他锁定。若⼀个共享数据没有被锁定，则事务可以添加任何锁定。 数据库锁机制可以在多种粒度上对共享数据资源进⾏锁定处理。 在典型DBMS产品中，⼀般可以在数据库、表、⻚⾯、⾏的粒度级别 上进⾏资源锁定。锁定的粒度越⼤，DBMS管理就越容易，但系统并发数据处理能⼒就越差。锁定的粒度越⼩，DBMS管理就越复杂，但系统并发数据处理能⼒就越强。 只要没有提交，那么事务处理共享数据仅仅是在自己获得的最初值上处理。也就是说，可以理解为共享数据将自己拷贝了n份分发给了n个并发执行的事务，如果有一个事务进行了提交，那么仅仅是数据库中数据更新，其他事务分发到的“拷贝”并不会同时进行更新。 想了想上面的例子还是不够全面和确切，那就从原理来看，我们知道并行调度机制的流程图，对于共享数据，事务提取的都是来自缓冲区的（提交后将缓冲区数据传回数据库）事务1修改数据后【缓冲区数据已被更改】事务2读取【读的是来自缓冲区的数据】到的就是1修改后的数据；如果事务1修改的同时事务2读取，因为缓冲区数据此时并未被修改，读到的是原本的值，然后两事务就相当于以上面的比喻独立的执行了，最后可能出现覆盖等等情况。 基于锁的并发控制协议锁：假定命名共享数据D Lock-S（D）共享锁定 Lock-X（D）排他锁定 Unlock（D）释放锁 协议 说明 脏读 不可重复读 幻象读 丢失更新 一级加锁协议 修改共享数据前加X，事务处理完成解锁 ❌ ❌ ❌ ✔ 二级加锁协议 一级基础上，读共享前加S，读完解锁 ✔ ❌ ❌ ✔ 三级加锁协议 一级基础上，读共享前加S，事务执行完解锁 ✔ ✔ ✔ ✔ 并发事务可串行化调度——两阶段锁定协议操作调度 两阶段锁定协议指所有并发事务在进⾏共享数据操作处理时，必 须按照两个阶段（增⻓阶段、缩减阶段）对共享数据进⾏加锁和解锁 申请。在增⻓阶段，事务可以对共享数据进⾏加锁申请，但不能释放 已有的锁定；在缩减阶段，事务可以对已有的锁定进⾏释放，但不能 对共享数据提出新的加锁申请。 是一个很绝对的判断：遵从两阶段锁定协议，则事务的任何并发调度都是可串行化调度——可以保持数据库一致性。【但反过来就未必了】 死锁 互斥条件 请求和保持条件 不剥夺条件 环路等待条件 安全管理 问题： 黑客利用系统漏洞，攻击数据库系统运行，窃取与篡改系统数据。 内部人员非法地泄露、篡改、删改系统的用户数据。 系统运维人员 操作失误导致数据被删除或数据库服务器系统宕 机。 系统软硬件故障导致数据库的数据损坏、数据丢失、数据库实 例⽆法启动。 • 意外灾害事件（⽕灾、⽔灾、地震等⾃然灾害）导致系统被破 坏。 用户——用户身份鉴别（身份认证系统 数据库应用系统）——用户存取权限控制（DBMS）——操作系统安全保护（OS）——数据加密存储（数据库） 最基本的：用户授权与访问权限控制 用户和角色的多对多 在DBMS中，⾓⾊分为预定义的系统⾓⾊和⽤户定义⾓⾊两种。 系统⾓⾊是数据库系统内建的⾓⾊，它们在数据库系统中已经被定义好相应的操作权限。 ⽤户⾃定义⾓⾊ 则是 DBA 根据业务应⽤需求，设计了不同权限范围的⽤户类别。 数据库备份备份内容：用户数据库、数据库结构、系统参数的系统数据库 备份方式： 完整数据库备份：花费更多时间和存储空间 差异数据库备份：只备份自上次数据库备份以来发生变化的数据 事务日志备份：只备份自上一次日志备份以来的事务日志数据——可以支持事务的回滚操作，可以将数据库恢复到故障点时刻的状态 文件备份：数据库通常由存储在磁盘上的若干数据文件构成。——可以直接通过复制数据库文件方式实现数据库备份，文件备份方式与事务日志备份方式结合才有实际意义 ——备份时刻是否需要停止实例运行？ 冷备份：停止。能够保证数据库完整性备份 热备份：不停止。较好地实现实时数据备份 ODBC","categories":[],"tags":[{"name":"数据库","slug":"数据库","permalink":"https://ysh-lr.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"}]},{"title":"数据库(B版)","slug":"数据库","date":"2022-05-27T10:18:09.000Z","updated":"2022-05-29T03:39:49.542Z","comments":true,"path":"posts/a772cedd.html","link":"","permalink":"https://ysh-lr.github.io/posts/a772cedd.html","excerpt":"","text":"数据库乱序复习(B版)基础知识 SQL——结构化查询语言——非过程化但也不是面向对象 是一种对关系数据库进行访问的数据操作语言 数据定义语言（DDL）数据库对象：数据库【database】、数据库表【table】、索引【index】、视图【view】、触发器【trigger】、存储过程【function】 创建——create 创建表时，同时创建其属性以及列完整性约束 ⼀个数据库不允许有两个表同名。在⼀个表中，可以定义多个列，但不允许有两个属性列同名。 第一种定义方式——只能定义单列主键 create table table_1 ( attribute_1 char(13) primary key, attribute_2 char(12) not null, attribute_3 data unique, attribute_4 text null check(attribute_4 in('喵喵'，'呼噜呼噜')), attribute_5 varchar(2) not null default '逢考必过' ) 第二种定义方式——可以定义复合主键和外键 create table_2 ( attribute_6 varchar(2) not null, attribute_7 varchar(5) not null, attribute_1 char(13) not null, attribute_8 char(2) not null check(attribute_8 in ('男性','女性')), constraint table2_PK primary key(attribute_6,attribute_7), constraint attribute_1_FK foreign key(attribute_1) references table_1(attribute_1) on delete cascade on update cascade ) 创建索引：create index &lt;索引名&gt; on &lt;表名&gt;&lt;(列名)&gt; create index index_1 on table_1 (name); 创建视图：create view&lt;视图名&gt;[(列名1),(列名2),…] as&lt;select查询&gt; 不指定列名默认为所有列。 删除——drop DROP DATABASE语句不能⽤在存储过程、触发器、事务处理程序中。 修改——alter 更改名字：alter &lt;对象&gt; &lt;对象原名称&gt; rename to &lt;新名称&gt; 对于数据表：修改已有的列，则操作后加column,修改还不存在的列（添加）不用加add #添加 alter table table_1 add name varchar(20) not null; #删除 alter table table_1 drop column attribute_3 #修改 alter table table_1 alter column attribute_2 type money 被宝贝考察 create table baby ( id serial, name varchar(3) not null check(name in('zyh','smy')) ); insert table baby values('zyh'); insert table baby values('smy'); 显然错误，甚至于是语法都不对QAQ，不复习菜得抠脚 create table baby ( id serial primary key, name varchar(3) not null check(name in('zyh','smy')) ); insert into baby(name) values('zyh'); insert into baby(name) values('smy'); insert 插入数据是与into组合在一起的，完整的是insert into insert into后面不加table 也是宝贝想和我说的，诚然，serial是代理键自动生成，但是，你插入的时候是默认的全列插入啊，所以必须在insert into &lt;表名&gt;后面加上属性列表 一般代理键后加not null或者primary key 数据操纵语言（DML）对数据库表表中数据进行操作 插入——insert insert into &lt;表名或者视图名&gt;[&lt;列名表&gt;] **values(列值表)**； &lt;&gt;内内容为必须，&lt;&gt;去掉，[ ]中为可选 insert into table_1(attribute_1,attribute_2,attribute_4,name) values('1010101010101','101001010101','喵喵','zyh'); insert into table_1 values('1010101010102','101001010102','加油各位','喵喵','其他人'); 更新——update update &lt;表名|视图名&gt; set &lt;列名1&gt;=&lt;表达式1&gt; [,&lt;列名2&gt;=&lt;表达式2&gt;…] [where &lt;条件表达式&gt;] update table_1 set name = 'smy and zyh' where attribute_1 = '1010101010101' 删除——delete delete from &lt;表名|视图名&gt; [where &lt;条件表达式&gt;] delete from table_1 where attribute_1 = '1010101010102' 数据查询语言（DQL）对数据库表表中数据进行操作 单表数据查询**select ** [all|distinct] &lt;列名&gt;[,&lt;列名&gt;…] [into&lt;新表&gt;] from &lt;表名|视图名&gt;,[,&lt;表名&gt;…] [where &lt;条件&gt;] [group by &lt;列名&gt;[having &lt;条件&gt;]] [order by &lt;列名&gt; [ASC|DEC]] Where子句①between…and限定列值范围 ②like通配符/not like：_代表一个未指定的字符；%代表一个或多个未指定的字符 ③and 、or、 not；in、not in、is null、is not null order byDESC降序 ；ASC升序 order by &lt;列名&gt; ASC（默认）|DESC 内置函数聚合函数：AVG()求指定列数据的平均值 COUNT()计算结果集行数 MIN()结果集指定列的最小值 MAX()最大值 SUM()总和 注意题目要求，查询年龄最大最小对应出生日期分别是最小最大 SQL聚合函数和分组统计select Major as 专业,count(StudentID) as 学生人数 from Student group by Major; 在group by语句中，可以同时使用where子句和having子句进行分组统计，先使用where子句选择符合条件的元组——&gt;作为分组的对象，然后形成分组，最后应用having条件，筛选分组后的结果进行统计 注意：除了GROUP BY语句外，列的名称是不允许和聚合函数一起混合使用。以下语句不规范。 SELECT MaxHours,SUM(MaxHours) FROM PROJECT WHERE ProjectID &lt;= 1200; ❌ DBMS产品在使用聚合函数的方式也不一样。一般来说，聚合函数是不能用于WHERE子句中的。 SELECT ProjectID,MaxHours FROM PROJECT WHERE MaxHours &lt; AVG(MaxHours); ❌ 多表语句查询子查询 子查询SQL语句基本格式： SELECT &lt;目标列&gt;[，&lt;目标列&gt;…] FROM &lt;表名&gt; WHERE &lt;条件中嵌套另一关系表的SELECT 查询结果集&gt; 在选课管理系统数据库中，我们希望检索出“计算机学院”的教师名单。该操作需要关联教师信息表（Teacher）和学院信息表（College），才能获得这些数据。这⾥可采⽤⼦查询⽅法实现两表 关联查询，其查询SQL语句如下。 select TeacherID,TeacherName,TeacherTitle from teacher where CollegeID in (select CollegeID from College where CollegeName='计算机学院') Order by TeacherID; 子查询：where里面嵌套查询——受限于性能，不能过多嵌套。 ​ 只有在最终查询结果来自一个表时有效。 连接查询 在选课管理系统数据库中，我们希望得到各个学院的教师⼈数信息。该操作需要关联教师信息表（Teacher）和学院信息表 （College），查询学院名称、教师⼈数，输出按名称降序排列。这时 需要采⽤连接查询⽅法实现两表关联查询，其查询 SQL语句如下。 select College.CollegeName as 学院名称，count(Teacher.CollegeID) as 教师人数 from College,Teacher where College.CollegeID = Teacher.TeacherID group by College.CollegeName order by College.CollegeName DESC; 注意：分组列名与排序列名要一致。 在选课管理系统数据库中，我们希望得到各个学院的 教 师 信 息 。 这 需 要 关 联 教 师 信 息 表 （ Teacher ） 和 学 院 信 息 表 （ College ） ， 查 询 CollegeName 、 TeaherID 、 TeacherName 、 TeacherGender、TeacherTitle 等信息，按学院名称、编号分别排序 输出，其查询 SQL 语句如下： select C.CollegeName as 学院名,T.TeacherID as 教师号，T.TeacherName as 教师姓名,T.TeacherGender as 性别,T.TeacherTitle as 教师职称 from Teacher as T,College as C where T.CollegeID = C.CollegeID order by C.CollegeName,T.TeacherID JOIN…ON select C.collegeName as 学院名,T.TeacherID as 教师号，T.TeacherName as 教师姓名,T.TeacherGender as 性别,T.TeacherTitle as 教师职称 from Teacher as T join College as C on T.collegeID = C.CollegeID order by C.collegeName,T.teacher select from &lt;表名1&gt;join&lt;表名2&gt;on&lt;连接条件&gt;join&lt;表名3&gt;on&lt;连接条件&gt; ————————————–内连接👆 ————————————–外连接👇 **LEFT JOIN **:左外连接,即使右表中没有匹配,也从左表返回所有的行【向左看齐，左表有多少行满足查询条件最终就有多少行】 RIGHT JOIN：右外连接，即使左表中没有匹配，也从右表返回所有的行【向右看齐】 FULL JOIN：全外连接，只要其中一个表中存在匹配，就返回行。 数据控制语言(DCL)对数据库对象访问权进行控制 授权——grant grant&lt;权限列表&gt;on&lt;数据库对象&gt;to&lt;用户或角色&gt; 拒绝授权——deny deny&lt;权限列表&gt;on&lt;数据库对象&gt;to&lt;用户或角色&gt; 收回权限——revoke revoke &lt;权限列表&gt; on &lt;数据库对象&gt; from&lt;用户或角色&gt; 用户创建 create user &lt;用户名称&gt; with [(权限列表:) superuser|nosuperuser createdb|nocreatedb createrole|nocreaterole inherit|noinherit：继承 login|nologin replication|noreplication：是否有复制权限 bypassrls|nobypassrls connection limit connlimit encrypted|unencrypted password ‘ ‘ valid until ‘timestamp’ in role 角色名 ] create user \"userA\" with login nosuperuser nocreatedb nocreaterole noreplication inherit connection limit -1 password '123456' 在用户创建中，默认具有登录权限，而在角色创建中，默认不具有登录权限。 用户删除：drop 权限 权限类别 数据库对象访问操作权限 用户在数据库中被赋予的特定数据库对象的数据访问操作权限，如对数据库表的select , iinsert, update ,delete数据操作权限。 数据库对象定义操作权限 用户在数据库中被赋予的数据库对象创建、删除、修改权限。 在3.7.1节的⼯程项⽬管理系统中，DBA赋予员⼯⽤户 （userA）对部门表（Department）、员⼯表（Employee）、项⽬ 表（Project）和任务表（Assignment）的读取数据权限。实现⽤户 授权的SQL程序如下。 grant select on Department to \"userA\"; grant select on Employee to \"userA\"; grant select on Project to \"userA\"; grant select on Assignment to \"userA\"; ⼯程项⽬管理系统中，假定需要在 ProjectDB数据库内创建经理⾓⾊ Role_Manager。该⾓⾊具有登录权限（Login）和⾓⾊继承权限，但它不是超级⽤户，不具有创建数据库 权限、创建⾓⾊权限、数据库复制权限，此外数据库连接数不受限 制。经理⾓⾊Role_Manager的创建SQL语句如下。 create role \"Role_Manager\" with login inherit nosuperuser nocreatedb nocreaterole noreplication connection limit -1; 为了使Role_Manager⾓⾊还具有操作访问数据库 ProjectDB 中的数据库表权限,DBA需要执⾏如下授权SQL语句。 grant select,insert,delete,update on Department to \"Role_Manager\" 事务处理语言（TPL）事务 开始——begin transaction 提交——commit ——数据变更的提交处理 回滚——rollback 保存——savepoint——部分SQL操作的结果数据保存，避免取消过多的事务数据操作 在选课管理数据库 CurriculaDB 中，使⽤事务程序实 现对学院信息表 College的数据插⼊，其事务SQL程序如下。 begin insert into college(collegeID,collegeName) values('0001','计算机学院'); insert into college(collegeID,collegeName) values('0002','信通学院'); commit; insert数据插入语句执行后，并没有立即提交数据库，而是在执行commit之后一起提交。 在选课管理数据库CurriculaDB中，使⽤事务程序对课程表Course插⼊数据，并在事务处理语句中加⼊保存点语句，其事务SQL程序如下。 begin insert into course values('C001','数据库'); insert into course values('C002','计算机网络'); savepoint temppoint; insert into course values('C003','面向对象编程'); rollback to tamppoint commit; 锁：假定命名共享数据D Lock-S（D）共享锁定 Lock-X（D）排他锁定 Unlock（D）释放锁 游标控制语言（CCL）数据库游标结构 定义——declare 提交游标数据——fetch into 关闭——close SQL语言数据类型注意事项单引号问题： 字符(char varchar text)、日期(date datetime)处理时需要加单引号，货币类型（money）不加单引号。 数据库备份postgresql数据库软件本身提供：pg_dump备份单个数据库,pg_dumpall备份整个数据库集群及系统全局数据库","categories":[],"tags":[{"name":"数据库","slug":"数据库","permalink":"https://ysh-lr.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"}]},{"title":"软件安全(二)","slug":"软件安全-1","date":"2022-05-25T11:24:21.000Z","updated":"2022-05-26T09:36:01.198Z","comments":true,"path":"posts/674dd97b.html","link":"","permalink":"https://ysh-lr.github.io/posts/674dd97b.html","excerpt":"","text":"关于老师上课反复强调的： 最小权限原则 stride模型：哄骗、篡改、抵赖、信息泄露、拒绝服务、权限提升 •CH01：计算环境与软件安全基础​ 机器语言 : 由二进制构成的计算机语言 软件安全保护什么？ 软件的完整性、可用性、可信性。 ①软件自身安全 防止软件丢失、被破坏、被篡改、被伪造 ②软件存储安全 可靠存储，保密存储，压缩存储，备份存储 ③软件通信安全 安全传输、加密传输、网络安全下载、完整下载 ④软件使用安全 合法用户与非法用户，授权访问，防止软件滥用，防止软件窃取，软件的非法复制 ⑤软件运行安全 确保软件正常运行，功能正常 **7498－2的5种安全服务 ** •鉴别服务 •访问控制 •数据完整性 •数据保密性 •抗抵赖 7498-2的8种安全机制 •加密 •数字签名 •访问控制 •数据完整性 •数据交换 •业务流填充 •路由控制 •公证 漏洞和脆弱性 •安全漏洞（Security Hole）：计算机系统具有的某种可能被入侵者恶意利用的属性。 •有时安全漏洞也称为脆弱性（Vulnerability）。 •漏洞是软件的属性。 漏洞是系统的一组特性，恶意的主体（攻击者或者攻击程序）能够利用这组特性，通过已授权的手段和方式获取对资源的未经授权访问，或者对系统造成损害。 ​ 当系统的某个漏洞被入侵者渗透（exploit）而造成泄密时，其结果就称为一次安全事件（Security Incident） 脆弱状态:从已授权的状态转换到未授权的状态 攻击是以授权状态或脆弱状态开始，以受损状态为目标的状态变换。 安全的代码（secure code）： 能够抵抗恶意攻击的代码；安全的代码同时也是健壮的代码（robust code） 安全性代码（security code）： 实现安全功能的代码。 程序是“安全的”： 安全隐含某种程度的信任（trust），程序实现了期望的机密性、完整性、可用性及其功能。 •CH02：典型软件安全问题安全问题的来源:漏洞、攻击者、软件中存在的攻击路径（攻击面问题） 再次强调：漏洞是软件的属性 接下来一个一个分析这三个来源。 漏洞——软件安全威胁的根源漏洞类型设计漏洞【安全功能特性中】 实现漏洞【实际编码中】 产生漏洞的原因 软件或协议设计时的瑕疵； 软件或协议实现时的弱点； 软件自身的瑕疵； 系统和网络的错误配置 常见的安全设计问题 密码技术引入的败笔 ü创建自己的密码技术 ü选用了不当的密码技术 ü依赖隐蔽式安全 ü编写到程序中的密钥 ü错误地处理私密信息 对用户及其许可权限进行跟踪的薄弱或缺失 ü会话管理薄弱或者缺失 ü身份鉴别薄弱或缺失 ü授权薄弱或缺失 有缺陷的输入验证 •没有在安全的上下文环境中执行验证，如在服务器验证而在客户端没有验证 •验证例程不集中，验证应尽可能靠近用户输入，并应集中以便于核实 •不安全的组件边界 薄弱的结构性安全 ü过大的攻击面 ü在过高权限级别上运行进程 ü没有纵深防御 ü失效时的处理不安全 其他设计缺陷 ü代码和数据混在一起 ü错将信任寄予外部系统 ü不安全的默认值 ü未做审计日志 缺陷：故障或者失效 来源（有意的或无意的） 有意的： 恶意的 非恶意的 无意的： 确认错误 域的错误 顺序化和混淆现象 不完全的身份识别和认证 边界条件违反 其他可利用的逻辑错误 意外行为：软件安全性缺陷，是由于程序脆弱性而引起的程序不适当反应 常见缺陷：缓冲区溢出、未校验输入、资源竞争、访问控制问题、认证、授权、加密缺陷 编程语言中的问题看PPT 平台的实现问题平台是指程序在其中所运行的环境，包括操作系统以及与之交互的组件。 威胁的来源： •软件与用户的交互 •软件与网络交互 •软件与文件系统交互 •软件依赖OS产生新的子进程 •软件与其他进程通信 •其他 平台问题 符号链接、目录遍历、字符转换 应用程序安全问题SQl注入 描述：攻击者通过操纵程序某种输入，在连接到SQL数据库的应用程序上执行自己的查询语句。 预防方法：过滤所有输入，确保输入字段只包含所需要的字符；尽量避免动态生成的SQL 哪类表单特别容易受到SQL攻击？某些用户的输入内容直接用来构造（或者影响）动态SQL命令，或作为存储过程的输入参数 ‘or’1=1 跨站点执行脚本XSS 描述：网络部分环境(或站点)具有更高的受信任级别高于其他环境,来自非受信环境的攻击者可在受信的环境注入数据,使其在受信环境作为脚本予以执行,或访问数据 预防方法： 示例： &lt;input type=\"text\" name=\"address1\" value=\"value1from\"&gt; XSS①:value1from = \"&gt;&lt;script&gt;alert(document.cookie)&lt;/script&gt;&lt;!- XSS②；\"onfocus=\"alert(document.cookie) 部署上的薄弱性 部署的执行者一般不属于开发团队。 软件错误地设置键值，使得系统上的其他用户可以进行更改 使软件安装时具有不必要的权限 示例： OWASP-10 A1-注入——当不可信的数据作为命令或查询语句的一部分被发送给解释器时 A2-失效的身份验证——与身份验证和会话管理相关——冒充其他用户的身份 A3-跨站脚本——收到不可信的数据并在未适当验证的情况下，将其发生送给一个网页浏览器——在受害者浏览器上执行脚本，劫持会话、危害网站、或者将用户转向恶意网站。 A4-不安全的直接对象引用——当开发人员暴露一个对内部对象的引用时——产生不安全的直接对象引用——攻击者可以操纵这些引用去访问未授权数据 A5-安全配置错误——应用程序、框架、应用程序服务器、web服务器、数据库服务器、平台的默认设置并不是安全的——需要维护 A6-敏感信息泄露——很多应用程序没有正确的保护敏感数据——蜜柑数据需要额外保护，在运输和存储、与浏览器交换过程中加密 A7-功能级访问控制缺失——应用程序需要在每个功能被访问时在服务端执行相同的访问控制检查——如果没有被验证，攻击者能够伪造请求一在未经适当授权时访问功能。 A8-跨站请求伪造（CSRF）——迫使登陆用户的浏览器将伪造的HTTP请求（包括该用户的会话cookie和其他认证信息）发送给到一个存在漏洞的未必应用程序 A9-使用含有已知漏洞的组件——组件（库文件、框架、其他软件模块）几乎是已全部的权限运行——如果一个带有漏洞的组件被利用，这种攻击可以造成更为严重的数据攻击或服务器接管——应用程序使用带有已知漏洞的组件会破坏应用程序防御系统，并使一系列可能的攻击和影响成为可能。 A10-未验证的重定向和转发——用户可能会被重定向和转发到其他网页和网站，并且利用不可信的数据去判定目的页面。——重定向至钓鱼软件或恶意软件。 •CH03：安全软件工程SSE-CMM看不懂啊，什么叫通用实施？过程能力的实现和制度化实施 ……不懂不懂 放过孩子吧，球球了 安全工程三个基本过程：风险、工程、保证 •CH04：安全测试的概念静态代码测试比较适用于早期的代码开发阶段，而不是测试阶段。 渗透测试攻击性测试,测试人员手动或利用自动化工具模拟黑客的输入——真实有效、覆盖率低、对Dos威胁测试效率高 模糊测试使用异常输入、非预期输入、甚至是随机输入——其他测试技术的补充——扩大了代码覆盖范围，提高了代码覆盖率测试程度——会触发一些平时不会触发的执行流 程序数据扫描内存测试——缓冲区溢出 程序安全性测试典型问题①明确区分系统中不同用户权限 ②系统中会不会出现用户冲突 ③更改用户权限会不会造成混乱 ④用户登陆密码是否可见、可复制 ⑤是否可以通过绝对路径登录 ⑥退出系统后是否删除了所有鉴权标记，是否可以使用后退键不通过输入口令进入系统 网络安全测试典型问题参考①测试采用的防护措施是否已经正确装配好，有关系统的补丁是否打上； ②模拟非授权攻击，看防护系统是否坚固 ③采用成熟的网络漏洞检查工具检查系统相关漏洞； ④采用木马检查工具检查系统木马情况 ⑤采用各种防外挂工具检查系统各组程序的外挂漏洞 数据安全测试考虑问题参考①系统数据是否机密 ②系统数据的完整性 ③系统数据可管理性 ④系统数据独立性 ⑤系统数据可备份和恢复能力 安全的常规测试方法 基于风险的安全测试 白盒、灰盒、黑盒测试 基于风险的安全测试威胁建模==风险建模 信息搜集 熟悉程序的设计、了解程序访问入口位置、了解程序所涉及的信息资产——需要保护的信息。 搜集方法： 程序设计文档的评审 设计人员和架构师的会谈（组件框架、组件间数据流、来自进程空间之外的数据流） 运行时分析——使用调试和诊断程序 威胁建模 可用性分析 安全规则学习错误 最小化攻击面 采用深度防御 使用最小权限 应用缺省安全 记住兼容性的倒退是痛苦的 假定外部系统是不安全的 基于错误计划 切记安全的特性不等于安全特性 不要依赖隐蔽式安全 不要混合编码和数据 正确修复安全问题 •CH05：安全的代码软件安全的目标：维护信息资源的保密性、完整性、和可用性。 基于客户端的客户端控制所带来的安全性收益是有限的。 软件漏洞可以超出软件本身的范围 12个规则——https://ysh-lr.github.io/posts/e7d67033.html •CH06：一个信息系统的安全模型•CH07：WEB应用安全web应用可以理解为利用HTTP与用户或者其它系统实现交互的C/S程序。而用户使用的CLIENT一般是类似于IE等的浏览器或者是专门开发的HTTP代理。 webSERVICE是一个打包在一起的功能集合，作为一个实体，发布至其他网络被其他程序所使用。 web APPLICATION： 采用HTTP协议完成通信的应用程序 与后台web server实现交互的程序 与互联网服务器，包括ｗｅｂ ｓｅｒｖｅｒ，database server进行交互的程序 位于中间层,进行数据交互或者其他服务程序 特征 •远程客户端程序 ​ •专用客户端 ​ •BROWSER •通过Internet进行数据通信 •后端系统包括WEB Server，OS，以及数据库 •可能包括中间层（中间件） ​ •中间层应用实现客户端数据处理或者其他服务 ​ •中间层应用请求服务数据 微软web应用安全框架 •步骤 1 ：确定安全目标。目标清晰有助于将注意力集中在威胁建模活动上，以及确定后续步骤要做多少工作。 •步骤 2 ：创建应用程序概述。逐条列出应用程序的重要特征和参与者有助于在步骤 4 中确定相关威胁。 •步骤 3 ：分解应用程序。全面了解应用程序的结构可以更轻松地发现更相关、更具体的威胁。 •步骤 4 ：确定威胁。使用步骤 2 和 3 中的详细信息来确定与应用程序方案和上下文相关的威胁。 •步骤 5 ：确定漏洞。检查应用程序的各层以确定与威胁有关的弱点。使用漏洞类别来帮助关注最常出现错误的区域。 输入 步骤 输出 业务需求 安全策略 兼容性要求 步骤 1 ：确定安全目标 主要安全目标 部署关系图 用例 功能说明 步骤 2 ：创建应用程序概述 带有端对端部署方案的白板样式关系图 主要方案 角色 技术 应用程序安全机制 部署关系图 用例 功能说明 数据流关系图 步骤 3 ：分解应用程序 信任边界 入口点 出口点 数据流 常见威胁 步骤 4 ：确定威胁 威胁列表 常见漏洞 步骤 5 ：确定漏洞 漏洞列表 类别 描述 漏洞 威胁或攻击 对策 输入和数据验证 如何知道应用程序接收的输入是有效且安全的呢？输入验证是指应用程序在进行其他处理之前如何筛选、删除或拒绝输入。 •在超文本标记语言 (HTML) 输出流中使用未经验证的输入 •使用用于生成 SQL 查询的未经验证的输入依赖于客户端验证 •使用输入文件名、URL 或用户名进行安全决策 •对于恶意输入，只使用应用程序筛选器 •查找输入的已知无效模式 •缓冲区溢出 •跨站点脚本 •SQL 注入 •标准化攻击 •不要信任输入。 •验证输入：长度、范围、格式和类型。 •限制、拒绝和净化输入。 •对输出进行编码。 身份验证 您是谁？身份验证是一个实体验证另一个实体身份的过程，通常通过凭据进行，例如用户名和密码。 •使用较弱的密码 •在配置文件中存储明文凭据 •通过网络传递明文凭据 •允许越权帐户 •允许延长的会话周期 •将个人设置与身份验证混合 •网络窃听 •强力攻击 •字典攻击 •Cookie 重播攻击 •盗窃凭据 •使用强密码策略。 •不要存储凭据。 •使用不需要通过网络传递明文凭据的身份验证机制。 •对通信信道进行加密以保护身份验证令牌。 •HTTPS 只与窗体身份验证 cookie 一起使用。 •将匿名验证从已验证的页面中分离出来。 授权 您可以做什么？授权是应用程序提供对资源和操作的访问控制的方式。 •依赖单一网关 •无法根据应用程序标识锁定系统资源 •无法限制对指定存储过程的数据库访问 •使用不合适的权限分离 • •提升特权 •泄漏机密数据 •篡改数据 •引诱攻击 •使用具有最少权限的帐户。 •考虑访问细分粒度。 •实行权限分离。 •使用多个网关。 •根据系统标识保护系统资源。 配置管理 应用程序以谁的身份运行？它连接到哪个数据库？如何管理应用程序？如何保护这些设置？配置管理指的是应用程序如何处理这些操作问题。 •使用不安全的管理界面 •使用不安全的配置存储 •存储明文配置数据 •拥有太多管理员 •使用越权进程帐户和服务帐户 •未经授权访问管理界面 •未经授权访问配置存储 •检索明文配置机密信息 •缺乏个人问责制 •越权的进程和服务帐户 •使用具有最少权限的服务帐户。 •不要以明文形式存储凭据。 •在管理界面上使用强身份验证和授权。 •不要使用本地安全机构 (LSA)。 •避免在 Web 空间中存储敏感信息。 •只使用本地管理。 敏感数据 您的应用程序如何处理敏感数据？敏感数据是指您的应用程序如何处理必须受到保护的所有数据，不管数据是在内存中、网络上还是永久性存储中。 •在不需要时存储机密信息 •在代码中存储机密信息 •以明文形式存储机密信息 •在网络上以明文形式传递敏感数据 •访问存储中的敏感数据 •访问内存中的敏感数据（包括进程转储） •网络侦听 •信息泄漏 •不要在软件中存储机密信息。 •加密通过网络传递的敏感数据。 •保护信道 会话管理 您的应用程序如何处理和保护用户会话？会话是指用户与您的 Web 应用程序之间的一系列相关交互。 •通过未加密的信道传递会话标识符 •允许延长的会话周期 •拥有不安全的会话状态存储 •在查询字符串中放置会话标识符 •会话攻击 •会话重播 •中间人攻击 •按照匿名用户、已标识用户和经过身份验证的用户划分站点。 •减少会话超时。 •避免在会话存储中存储敏感数据。 •保护通往会话存储的信道。 •验证和授权对会话存储的访问。 加密 如何保持机密（保密性）？如何防止他人篡改您的数据或库（完整性）？如何为必须具有很强机密性的随机值提供种子？加密是指应用程序保证机密性和完整性的方式。 •使用自定义加密 •使用的算法不正确，或者密钥长度太短 •无法保护加密密钥 •在延长的时间内使用同一密钥 •以不安全的方式分配密钥 •丢失解密密钥 •加密破解 •不要开发和使用专用算法（XOR 不是加密。使用平台提供的加密算法）。 •使用 RNGCryptoServiceProvider 方法生成随机数字。 •避免密钥管理。在适当的地方使用 Windows 数据保护 API (DPAPI)。 •定期更改您的密钥。 参数操作 您的应用程序如何操作参数值？对于应用程序，表单域、查询字符串参数和cookie值经常作为参数使用。参数操作既指应用程序保护这些值不被篡改的方式，也指应用程序处理输入参数的方式。 •无法验证所有输入参数 •在未加密的 cookie 中存储敏感数据 •在查询字符串和表单域中存储敏感数据 •信任 HTTP 标头信息 •使用无保护的视图状态 •查询字符串操作 •表单域操作 •Cookie 操作 •HTTP 标头操作 •不要信任客户端可以操作的字段。这些字段包括查询字符串、表单域、cookie 值以及 HTTP 标头。 异常管理 当应用程序中的一个方法调用失败时，您的应用程序会做什么？显示了多少？您是否将错误信息友好地返回给最终用户？您是否将有价值的异常信息传递给调用方？应用程序的失败方式是否友好？ •无法使用结构化异常处理 •显示太多的信息给客户端 •显示敏感系统或应用程序细节 •拒绝服务攻击 •使用结构化异常处理（通过使用 try/catch 块）。 •只有在操作添加值/信息时才捕获和包装异常。 •不要显示敏感系统或应用程序信息。 •不要记录私人数据，例如密码。 审核与记录 谁在什么时候做了什么？审核与记录是指应用程序记录与安全相关的事件的方式。 •无法审核失败的登录 •无法保护审核文件 •无法跨应用程序层进行审核 •用户拒绝执行某项操作 •攻击者利用了某个应用程序而没有留下踪迹 •攻击者可以掩盖他的踪迹 •识别恶意行为。 •了解您的基线（了解什么是良好的业务流）。 •使用应用程序规范公开可以监视的行为。 一个安全模型电子商务:Web site(CMS-powered)、在线商店 两个服务器：Application server Database server 物理安全 •服务器托管在主页寄存公司（hosting company）: ​ •严格限制物理访问 ​ •在入口采用生理特征识别方法 ​ •采用自锁方法 系统用户 •客户 (public). •商店管理职员. •市场部. •开发者. •系统管理员. •威胁: 由于采用明文通信协议的口令和数据危害 •消除方法: 禁用plain-text协议: ​ •在商店的采购过程 ​ •管理接口 ​ •数据库访问 入口点 •在网络层，每个服务代表了一个入口点. •利用防火墙，进行绝对必须的访问: ​ •外部防火墙(hosting company). ​ •主机防火墙(iptables on Linux). ​ •限制所有端口访问, only let port 3306 through. •威胁: 可能的威胁，Apache, SFTPD, SSHD, and MySQL. •消除: 阻止必须（非基础的）访问(SFTPD, SSHD, MySQL). •可选项: buy an expensive hardware firewall. 公众现在看到的 攻击面降低 •威胁: Apache中的可能的危害. •消除: Keep Apache up-to-date: ​ •Automated patching (use binary Apache) ​ •Manual patching (build Apache from source) •威胁: Apache misconfiguration导致的危害. •消除: Configuration management. •消除: 定期进行独立的配置评估. •威胁: Apache为消除问题导致的可能的危害 . •消除: Put Apache in jail（监狱）. •消除: 实现完整性验证. •消除: Implement kernel patches。 •威胁: 对手访问credit card database. •消除: Do not store credit cards online, or store them using public-key encryption. 消除: Document policy on the web site. •威胁: Store source code stolen. •消除: Do not keep the source code online, compile PHP pages before uploading。 •威胁: 由于其他应用导致的. •This opens a door to a new threat modelling sub-model: web application security. •由外部消除. Treat the application as a black box, and look where action gets out. •CH08: 隐私数据个人信息—以电子或其他方式记录的能够单独或者与其他信息结合识别特定自然人身份或者反应特定自然人活动情况的各种信息。 判定：一、从信息到个人，即有信息本身的特殊性识别出特定的自然人，即个人信息应有助于识别特定的个人； ​ 二、关联，从个人到信息。已知特定自然人，则由该人在其活动中产生的信息。 个人敏感信息：一旦泄露、非法提供或者滥用能危害人身安全和财产安全，导致个人名誉、身心健康受到损害或歧视性待遇的个人信息。 14岁以下儿童的个人信息和自然人的隐私信息属于个人敏感信息。 个人信息匿名化处理后所得的信息不属于个人信息，但匿名化比较困难，通常折中采用假名化，假名化后的信息依然属于个人信息。 基本原则和安全要求•a)权责一致原则——对其个人信息处理活动对个人信息主体合法权益造成的损害承担责任。 •b)目的明确原则——具有合法、正当、必要、明确的个人信息处理目的。 •c)选择同意原则——向个人信息主体明示个人信息处理目的、方式、范围、规则等，征求其授权同意。 •d)最少够用原则——除与个人信息主体另有约定外，只处理满足个人信息主体授权同意的目的所需的最少个人信息类型和数量。目的达成后，应及时根据约定删除个人信息。 •e)公开透明原则——以明确、易懂和合理的方式公开处理个人信息的范围、目的、规则等，并接受外部监督。 •f)确保安全原则——具备与所面临的安全风险相匹配的安全能力，并采取足够的管理措施和技术手段，保护个人信息的保密性、完整性、可用性。 •g)主体参与原则——向个人信息主体提供能够访问、更正、删除其个人信息，以及撤回同意、注销账户等方法。 GDPR适用于广泛的个人数据，还能保护个人在现实生活中和网络上的活动信息。 个人数据：任何信息 相关性 已识别或可识别 自然人 与已识别或可识别的自然人（即数据主体）相关的个人信息。 任何信息：客观（学历信息等）主观（评价）；不限于私人生活或家庭信息，也可以是个人参与的专业活动或公共活动的信息，比如个人的办公电话 相关性：指向个人或指向某物品、过程或事件，进而与个人产生关联——考虑信息的内容、目的或结果等因素 •所谓**“已识别或可识别”**，是指通过姓名、身份证件号码、IP地址等信息确定到某个人，也可能是综合各种信息确定到某个人。 •所谓**“自然人”**，是指所有人，不限于欧盟成员国的公民，不考虑个人的居民身份和国籍等。**机构和已死亡的人员**不是自然人，因此，其信息不属于个人数据。 •GDPR中个人数据处理的6大原则—— ​ •“合法公平透明”、 ​ •“目的限制”、 ​ •“数据最小化”、 ​ •“准确性”、 ​ •“储存限额”、 ​ •“完整性和机密性”。 个人信息法与GDPR•与GDPR一样，《个人信息保护法》具有广泛的域外管辖权。因此，即使是在中国没有业务的公司，如果从在中国的人那里收集数据，也可能受到新法律的影响。 •GDPR更宽容一些，例如，如果接收国拥有强大的数据保护制度，则可以在不增加额外保护的情况下传输数据，但是在中国不行。如果你要向中国境外发送数据，那是个人数据，在合法转移之前有先决条件。 •另一个不同之处在于，中国《个人信息保护法》有明确规定，政府部门不能越界，但公共安全和国家安全也有例外。 •此外，未经中国政府同意，公司不得转让与执法或司法事项有关的个人信息。法律要求那些在中国没有业务的外国公司指定一名当地代表，就像代理人一样，处理有关在中国收集的个人信息的问题。如果出现问题，这些公司仍然要承担责任。责任基本上延伸到个人信息的原始收集者。","categories":[],"tags":[{"name":"软件安全","slug":"软件安全","permalink":"https://ysh-lr.github.io/tags/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8/"}]},{"title":"软件安全(OWASP以及SD3)","slug":"软件安全","date":"2022-05-24T15:28:56.000Z","updated":"2022-05-24T15:30:59.881Z","comments":true,"path":"posts/e7d67033.html","link":"","permalink":"https://ysh-lr.github.io/posts/e7d67033.html","excerpt":"","text":"OWASP安全的目标•软件安全的目标是要维护信息资源的==保密性 ， 完整性 ，和 可用性==，以确保业务的成功运作。该目标通过实施 ==安全控制==来实现。本指南重点介绍具体的技术控制，以 缓解 常见软件 漏洞 的发生。 •开发团队根据功能需求文档和用例设计一个应用程序以执行特定的任务。 •而另一方面，攻击者，基于“没有具体说明应拒绝的行为，则被认为是可行的”原则，对于应用程序可以做什么更感兴趣。 •Web开发团队应当明白，基于客户端的输入验证、隐藏字段和界面控件（例如，下拉键和单选按钮）的客户端控制，所带来的安全性收益是有限的。 •攻击者可以使用工具，比如：客户端的 Web代理（例如，OWASP WebScarab，Burp）或网络数据包捕获工具（例如，Wireshark），进行应用程序流量分析，提交定制的请求，并绕过所有的接口。 •另外，Flash，JavaApplet 和其它客户端对象可以被反编译并进行漏洞分析。 软件安全漏洞的产生•软件的安全漏洞可以在软件==开发生命周期的任何阶段==被引入 •最初没有明确的==安全需求==； •创建有逻辑错误的==概念设计==； •使用糟糕的编码规范，从而带来了==技术漏洞==； •软件==部署==不当； •在==维护或者更新==过程中引入缺陷。 此外，还有重要的一点需要明白，==软件漏洞可以超出软件本身的范围==。根据不同的软件、漏洞和配套基础设施的性质，一次成功的攻击会影响下面任何或者所有的方面： •软件和其相关的信息； •相关服务器的操作系统； •后端数据库； •在共享环境中的其它应用程序； •用户的系统；与用户交互的其它软件。 12个规则1.输入验证•在可信系统（比如：服务器）上执行所有的数据验证。 •识别所有的数据源，并将其分为可信的和不可信的。验证所有来自不可信数据源（比如：数据库，文件流，等）的数据。 •应当为应用程序提供一个集中的输入验证规则。 •丢弃任何没有通过输入验证的数据。 •为所有输入明确恰当的字符集，比如：UTF-8。 •在输入验证前，将数据按照常用字符进行编码（ 规范化 ）。 •确定系统是否支持 UTF-8扩展字符集，如果支持，在 UTF-8解码完成以后进行输入验证。 •在处理以前，验证所有来自客户端的数据，包括：所有参数、URL、HTTP头信息（比如：cookie名字和数据值）。确定包括了来自 JavaScript、Flash或其他嵌入代码的 post back信息。 •验证在请求和响应的报头信息中只含有 ASCII字符。 •核实来自重定向输入的数据（一个攻击者可能向重定向的目标直接提交恶意代码，从而避开应用程序逻辑以及在重定向前执行的任何验证）。 •验证正确的数据类型。 •验证数据范围。 •验证数据长度。 •尽可能采用“白名单”形式，验证所有的输入。 •如果任何潜在的危险字符必须被作为输入，请确保执行了额外的控制，比如：输出编码、特定的安全 API、以及在应用程序中使用的原因。部分常见的危险字符包括：&lt; &gt; “ ‘ % ( ) &amp; + \\ ' \" 。 •如果使用的标准验证规则无法验证下面的输入，那么它们需要被单独验证： o 验证空字节 (%00)； o 验证换行符 (%0d, %0a, \\r, \\n)； o 验证路径替代字符“点-点-斜杠”（../或 ..\\）。如果支持 UTF-8扩展字符集编码，验证替代字符： %c0%ae%c0%ae/ (使用 规范化 验证双编码或其他类型的编码攻击)。 2.输出编码•在可信系统（比如：服务器）上执行所有的编码。 •为每一种输出编码方法采用一个标准的、已通过测试的规则。 •通过语义输出编码方式，对所有返回到客户端的来自于应用程序信任边界之外的数据进行编码。HTML实体编码是一个例子，但不是在所有的情况下都可用。 •除非对目标编译器是安全的，否则请对所有字符进行编码。 •针对 SQL、XML和 LDAP查询，语义净化所有不可信数据的输出。 • 对于操作系统命令，净化所有不可信数据输出。 3.身份验证和密码管理•除了那些特定设为“公开”的内容以外，对所有的网页和资源要求身份验证。 •所有的身份验证过程必须在可信系统（比如：服务器）上执行。 •在任何可能的情况下，建立并使用标准的、已通过测试的身份验证服务。 •为所有身份验证控制使用一个集中实现的方法，其中包括利用库文件请求外部身份验证服务。 •将身份验证逻辑从被请求的资源中隔离开，并使用重定向到或来自集中的身份验证控制。 •所有的身份验证控制应当安全的处理未成功的身份验证。 •所有的管理和账户管理功能至少应当具有和主要身份验证机制一样的安全性。 •只有当所有的数据输入以后，才进行身份验证数据的验证，特别是对连续身份验证机制。 •身份验证的失败提示信息应当避免过于明确。比如：可以使用“用户名和/或密码错误”，而不要使用“用户名错误”或者“密码错误”。错误提示信息在显示和源代码中应保持一致。 •为涉及敏感信息或功能的外部系统连接使用身份验证。 •只使用 HTTP Post 请求传输身份验证的凭据信息。 •用于访问应用程序以外服务的身份验证凭据信息应当加密，并存储在一个可信系统（比如：服务器）中受到保护的地方。源代码不是一个安全的地方。 •如果您的应用程序管理着凭证的存储，那么应当保证只保存了通过使用强加密单向 salted哈希算法得到的密码，并且只有应用程序具有对保存密码和密钥的表/文件的写权限（如果可以避免的话，不要使用 MD5算法）。 •密码哈希必须在可信系统（比如：服务器）上执行。 •非临时密码只在加密连接中发送或作为加密的数据（比如，一封加密的邮件）。通过邮件重设临时密码可以是一个例外。 •通过政策或规则加强密码复杂度的要求（比如：要求使用字母、数字和/或特殊符号）。身份验证的凭据信息应当足够复杂以对抗在其所部署环境中的各种威胁攻击。 •通过政策和规则加强密码长度要求。常用的是 8个字符长度，但是 16个字符长度更好，或者考虑使用多单词密码短语。 •输入的密码应当在用户的屏幕上模糊显示（比如：在 Web表单中使用“password”输入类型）。 • 当连续多次登录失败后（比如：通常情况下是 5次），应强制锁定账户。账户锁定的时间必须足够长，以阻止暴力攻击猜测登录信息，但是不能长到允许执行一次拒绝服务攻击。 •密码重设和更改操作需要类似于账户创建和身份验证的同样控制等级。 •密码重设问题应当支持尽可能随机的提问（比如：“最喜爱的书”是一个坏的问题，因为《圣经》是最常见的答案）。 •如果使用基于邮件的重设，只将临时链接或密码发送到预先注册的邮件地址。 •临时密码和链接应当有一个短暂的有效期。 •当再次使用临时密码时，强制修改临时密码。 •当密码重新设置时，通知用户。 •阻止密码重复使用。 •密码在被更改前应当至少使用了一天，以阻止密码重用攻击。 •根据政策或规则的要求，强制定期更改密码。关键系统可能会要求更频繁的更改。更改时间周期必须进行明确。 •为密码填写框禁用“记住密码”功能。 •用户账号的上一次使用信息（成功或失败）应当在下一次成功登录时向用户报告。 •执行监控以确定针对使用相同密码的多用户帐户攻击。当用户 ID可以被得到或被猜到时，该攻击模式用来绕开标准的锁死功能。 •更改所有厂商提供的默认用户 ID和密码，或者禁用相关帐号。 •在执行关键操作以前，对用户再次进行身份验证。 •为高度敏感或重要的交易账户使用多因子身份验证机制。 •如果使用了第三方身份验证的代码，仔细检查代码以保证其不会受到任何恶意代码的影响。 4.会话管理•使用服务器或者框架的会话管理控制。应用程序应当只识别有效的会话标识符。 •会话标识符必须总是在一个可信系统（比如：服务器）上创建。 •会话管理控制应当使用通过审查的算法以保证足够的随机会话标识符。 •为包含已验证的会话标识符的 cookie设置域和路径，以为站点设置一个恰当的限制值。 •注销功能应当完全终止相关的会话或连接。 注销功能应当可用于所有受身份验证保护的网页 •在平衡的风险和业务功能需求的基础上，设置一个尽量短的会话超时时间。通常情况下，应当不超过几个小时。 •禁止连续的登录并强制执行周期性的会话终止，即使是活动的会话。特别是对于支持富网络连接或连接到关键系统的应用程序。终止时机应当可以根据业务需求调整，并且用户应当收到足够的通知已减少带来的负面影响。 •如果一个会话在登录以前就建立，在成功登录以后，关闭该会话并创建一个新的会话。 •在任何重新身份验证过程中建立一个新的会话标识符。 •不允许同一用户 ID的并发登录。 •不要在 URL、错误信息或日志中暴露会话标识符。会话标识符应当只出现在 HTTP cookie头信息中。比如，不要将会话标识符以 GET 参数进行传递。 •通过在服务器上使用恰当的访问控制，保护服务器端会话数据免受来自服务器其他用户的未授权访问。 •生成一个新的会话标识符并周期性地使旧会话标识符失效（这可以缓解那些原标识符被获得的特定会话劫持情况）。 •在身份验证的时候，如果连接从 HTTP变为 HTTPS，则生成一个新的会话标识符。在应用程序中，推荐持续使用 HTTPS，而非在 HTTP和 HTTPS之间转换。 •为服务器端的操作执行标准的会话管理，比如，通过在每个会话中使用强随机令牌或参数来管理账户。该方法可以用来防止跨站点请求伪造攻击。 •通过在每个请求或每个会话中使用强随机令牌或参数，为高度敏感或关键的操作提供标准的会话管理。 •为在 TLS连接上传输的 cookie设置“安全”属性。 •cookie设置为 HttpOnly属性，除非在应用程序中明确要求了客户端脚本程序读取或者设置cookie的值。 5.访问控制•只使用可信系统对象（比如：服务器端会话对象）以做出访问授权的决定。 •使用一个单独的全站点部件以检查访问授权。这包括调用外部授权服务的库文件。 •安全的处理访问控制失败的操作。 •如果应用程序无法访问其安全配置信息，则拒绝所有的访问。 •在每个请求中加强授权控制，包括：服务器端脚本产生的请求，“includes”和来自象 AJAX 和FLASH那样的富客户端技术的请求。 •将有特权的逻辑从其他应用程序代码中隔离开。 •限制只有授权的用户才能访问文件或其他资源，包括那些应用程序外部的直接控制。 •限制只有授权的用户才能访问受保护的 URL。 •限制只有授权的用户才能访问受保护的功能。 •限制只有授权的用户才能访问直接对象引用。 •限制只有授权的用户才能访问服务。 •限制只有授权的用户才能访问应用程序数据。 •限制通过使用访问控制来访问用户、数据属性和策略信息。 •限制只有授权的用户才能访问与安全相关的配置信息。 •服务器端执行的访问控制规则和表示层实施的访问控制规则必须匹配。 •如果状态数据必须存储在客户端，使用加密算法，并在服务器端检查完整性以捕获状态的改变。 强制应用程序逻辑流程遵照业务规则。 •限制单一用户或设备在一段时间内可以执行的事务数量。事务数量/时间应当高于实际的业务需求，但也应该足够低以判定自动化攻击。 •仅使用“referer”头作为补偿性质的检查，它永远不能被单独用来进行身份验证检查，因为它可以被伪造。 •如果长的身份验证会话被允许，周期性的重新验证用户的身份，以确保他们的权限没有改变。如果发生改变，注销该用户，并强制他们重新执行身份验证。 •执行帐户审计并将没有使用的帐号强制失效（比如：在用户密码过期后的 30天以内）。 •应用程序必须支持帐户失效，并在帐户停止使用时终止会话（比如：角色、职务状况、业务处理的改变，等等）。 •服务帐户，或连接到或来自外部系统的帐号，应当只有尽可能小的权限。 • 建立一个“访问控制政策”以明确一个应用程序的业务规则、数据类型和身份验证的标准或处理流程，确保访问可以被恰当的提供和控制。这包括了为数据和系统资源确定访问需求。 6.加密规范•所有用于保护来自应用程序用户秘密信息的加密功能都必须在一个可信系统（比如：服务器）上执行。 •保护主要秘密信息免受未授权的访问。 •安全的处理加密模块失败的操作。 •为防范对随机数据的猜测攻击，应当使用加密模块中已验证的随机数生成器生成所有的随机数、随机文件名、随机 GUID和随机字符串。 •应用程序使用的加密模块应当遵从 FIPS 140-2或其他等同的标准（请见：http://csrc.nist.gov/groups/STM/cmvp/validation.html）。 •建立并使用相关的政策和流程以实现加、解密的密钥管理、错误处理和日志。 •不要在错误响应中泄露敏感信息，包括：系统的详细信息、会话标识符或者帐号信息。 •使用错误处理以避免显示调试或堆栈跟踪信息。 •使用通用的错误消息并使用定制的错误页面。 •应用程序应当处理应用程序错误，并且不依赖服务器配置。 •当错误条件发生时，适当的清空分配的内存。 •在默认情况下，应当拒绝访问与安全控制相关联的错误处理逻辑。 •所有的日志记录控制应当在可信系统（比如：服务器）上执行。 •日志记录控制应当支持记录特定安全事件的成功或者失败操作。 •确保日志记录包含了重要的日志事件数据。 •确保日志记录中包含的不可信数据，不会在查看界面或者软件时以代码的形式被执行。 •限制只有授权的个人才能访问日志。 •为所有的日志记录采用一个主要的常规操作。 •不要在日志中保存敏感信息，包括：不必要的系统详细信息、会话标识符或密码。 •确保一个执行日志查询分析机制的存在。 •记录所有失败的输入验证。 •记录所有的身份验证尝试，特别是失败的验证。 •记录所有失败的访问控制。 •记录明显的修改事件，包括对于状态数据非期待的修改。 •记录连接无效或者已过期的会话令牌尝试。 •记录所有的系统例外。 •记录所有的管理功能行为，包括对于安全配置设置的更改。 •记录所有失败的后端 TLS链接。 •记录加密模块的错误。 •使用加密哈希功能以验证日志记录的完整性。 7.数据保护•授予最低权限，以限制用户只能访问为完成任务所需要的功能、数据和系统信息。 •保护所有存放在服务器上缓存的或临时拷贝的敏感数据，以避免非授权的访问，并在临时工作文件不再需要时被尽快清除。 •即使在服务器端，仍然要加密存储的高度机密信息，比如，身份验证的验证数据。总是使用已经被很好验证过的算法，更多指导信息请参见“加密规范”部分。 •保护服务器端的源代码不被用户下载。 •不要在客户端上以明文形式或其他非加密安全模式保存密码、连接字符串或其他敏感信息。这包括嵌入在不安全的形式中：MS viewstate、Adobe flash 或者已编译的代码。 •删除用户可访问产品中的注释，以防止泄露后台系统或者其他敏感信息。 •删除不需要的应用程序和系统文档，因为这些也可能向攻击者泄露有用的信息。 •不要在 HTTP GET请求参数中包含敏感信息。 •禁止表单中的自动填充功能，因为表单中可能包含敏感信息，包括身份验证信息。 •禁止客户端缓存网页，因为可能包含敏感信息。“Cache-Control: no-store”，可以和 HTTP报头控制“Pragma: no-cache”一起使用，该控制不是非常有效，但是与 HTTP/1.0向后兼容。 •应用程序应当支持，当数据不再需要的时候，删除敏感信息（比如：个人信息或者特定财务数据）。 •为存储在服务器中的敏感信息提供恰当的访问控制。这包括缓存的数据、临时文件以及只允许特定系统用户访问的数据。 8.通讯安全•为所有敏感信息采用加密传输。其中应该包括使用 TLS对连接的保护，以及支持对敏感文件或非基于 HTTP连接的不连续加密。 •TLS证书应当是有效的，有正确且未过期的域名，并且在需要时，可以和中间证书一起安装。 •没有成功的 TLS连接不应当后退成为一个不安全的连接。 •为所有要求身份验证的访问内容和所有其他的敏感信息提供 TLS连接。 •为包含敏感信息或功能、且连接到外部系统的连接使用 TLS。 •使用配置合理的单一标准 TLS连接。 •为所有的连接明确字符编码。 •当链接到外部站点时，过滤来自 HTTP referer 中包含敏感信息的参数。 9.系统配置•确保服务器、框架和系统部件采用了认可的最新版本。 •确保服务器、框架和系统部件安装了当前使用版本的所有补丁。 •关闭目录列表功能。 •将 Web服务器、进程和服务的账户限制为尽可能低的权限。 •当例外发生时，安全的进行错误处理。 •移除所有不需要的功能和文件。 在部署前，移除测试代码和产品不需要的功能。 •通过将不进行对外检索的路径目录放在一个隔离的父目录里，以防止目录结构在 robots.txt文档中暴露。然后，在 robots.txt 文档中“禁止”整个父目录，而不是对每个单独目录的“禁止”。 •明确应用程序采用哪种 HTTP方法：GET 或 POST，以及是否需要在应用程序不同网页中以不同的方式进行处理。 •禁用不需要的 HTTP方法，比如 WebDAV 扩展。如果需要使用一个扩展的 HTTP方法以支持文件处理，则使用一个好的经过验证的身份验证机制。 •如果 Web服务器支持 HTTP1.0和 1.1，确保以相似的方式对它们进行配置，或者确保您理解了它们之间可能存在差异（比如：处理扩展的 HTTP方法）。 •移除在 HTTP相应报头中有关 OS、Web服务版本和应用程序框架的无关信息。 •应用程序存储的安全配置信息应当可以以可读的形式输出，以支持审计。 •使用一个资产管理系统，并将系统部件和软件注册在其中。 •将开发环境从生成网络隔离开，并只提供给授权的开发和测试团队访问。开发环境往往没有实际生成环境那么安全，攻击者可以使用这些差别发现共有的弱点或者是可被利用的漏洞。 •使用一个软件变更管理系统以管理和记录在开发和产品中代码的变更。 •数据库安全： •使用强类型的参数化查询方法。 •使用输入验证和输出编码，并确保处理了元字符。如果失败，则不执行数据库命令。 •确保变量是强类型的。 •当应用程序访问数据库时，应使用尽可能最低的权限。 •为数据库访问使用安全凭证。 •连接字符串不应当在应用程序中硬编码。连接字符串应当存储在一个可信服务器的独立配置文件中，并且应当被加密。 •使用存储过程以实现抽象访问数据，并允许对数据库中表的删除权限。 •尽可能地快速关闭数据库连接。 •删除或者修改所有默认的数据库管理员密码。使用强密码、强短语，或者使用多因子身份验证。 •关闭所有不必要的数据库功能（比如：不必要的存储过程或服务、应用程序包、仅最小化安装需要的功能和选项 •删除厂商提供的不必要的默认信息（比如：数据库模式示例）。 •禁用任何不支持业务需求的默认帐户。 应用程序应当以不同的凭证为每个信任的角色（比如：用户、只读用户、访问用户、管理员）连接数据库。 10.文件管理•不要把用户提交的数据直接传送给任何动态调用功能。 •在允许上传一个文档以前进行身份验证。 •只允许上传满足业务需要的相关文档类型。 •通过检查文件报头信息，验证上传文档是否是所期待的类型。只验证文件类型扩展是不够的。 •不要把文件保存在与应用程序相同的 Web环境中。文件应当保存在内容服务器或者数据库中。 •防止或限制上传任意可能被 Web服务器解析的文件。 •关闭在文件上传目录的运行权限。 •通过装上目标文件路径作为使用了相关路径或者已变更根目录环境的逻辑盘，在 UNIX 中实现安全的文件上传服务。 •当引用已有文件时，使用一个白名单记录允许的文件名和类型。 •验证传递的参数值，如果与预期的值不匹配，则拒绝使用，或者使用默认的硬编码文件值代替。 •不要将用户提交的数据传递到动态重定向中。如果必须允许使用，那么重定向应当只接受通过验证的相对路径 URL。 •不要传递目录或文件路径，使用预先设置路径列表中的匹配索引值。 •绝对不要将绝对文件路径传递给客户。 •确保应用程序文件和资源是只读的。 • 对用户上传的文件扫描进行病毒和恶意软件。 11.内存管理•对不可信数据进行输入和输出控制。 •重复确认缓存空间的大小是否和指定的大小一样。 •当使用允许多字节拷贝的函数时，比如 strncpy()，如果目的缓存容量和源缓存容量相等时，需要留意字符串没有 NULL终止。 •如果在循环中调用函数时，检查缓存大小，以确保不会出现超出分配空间大小的危险。 •在将输入字符串传递给拷贝和连接函数前，将所有输入的字符串缩短到合理的长度。 •关闭资源时要特别注意，不要依赖垃圾回收机制（比如：连接对象、文档处理，等）。 •在可能的情况下，使用不可执行的堆栈。 •避免使用已知有漏洞的函数（比如：printf，strcat，strcpy，等）。 •当方法结束时和在所有的退出节点时，正确地清空所分配的内存。 12.通用编码规范•为常用的任务使用已测试且已认可的托管代码，而不创建新的非托管代码。 •使用特定任务的内置 API以执行操作系统的任务。不允许应用程序直接将代码发送给操作系统，特别是通过使用应用程序初始的命令 shell。 •使用校验和或哈希值验证编译后的代码、库文件、可执行文件和配置文件的完整性。 •使用死锁来防止多个同时发送的请求，或使用一个同步机制防止竞态条件。 •在同时发生不恰当的访问时，保护共享的变量和资源。 •在声明时或在第一次使用前，明确初始化的所有变量和其他数据存储。 •当应用程序运行发生必须提升权限的情况时，尽量晚点提升权限，并且尽快放弃所提升的权限。 •通过了解您使用的编程语言的底层表达式以及它们是如何进行数学计算，从而避免计算错误。密切注意字节大小依赖、精确度、有无符合、 截尾操作、转换、字节之间的组合、“not-a-number”计算、以及对于编程语言 底层表达式 如何处理非常大或者非常小的数。 •不要将用户提供的数据传递给任何动态运行的功能。 •限制用户生成新代码或更改现有代码。 •审核所有从属的应用程序、第三方代码和库文件，以确定业务的需要，并验证功能的安全性，因为它们可能产生新的漏洞。 •执行安全更新。如果应用程序采用自动更新，则为您的代码使用加密签名，以确保的您的下载客户端验证这些签名。使用加密的信道传输来自主机服务器的代码。 SD3安全设计•安排具体的安全设计的人员； •进行安全教育； •确保威胁分析已经完成； •符合安全设计和编码的指导原则； •尽可能修补任何安全编程指南上的BUG; •确保安全指南是逐步改进的； •针对已经修复的缺陷开发回归测试； •简化代码和安全模型； •在打包以前完成穿透测试。 缺省安全•缺省状态下，不要设置所有的特点和功能； •允许最小权限； •恰当的资源保护。 安全提交•确认程序给管理员提供了安全功能； •尽可能提供高质量的补丁； •提供足够的信息以使用户安全的使用软件。","categories":[],"tags":[{"name":"软件安全","slug":"软件安全","permalink":"https://ysh-lr.github.io/tags/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8/"}]},{"title":"软件测试知识点汇总","slug":"post-5","date":"2022-01-29T14:55:08.000Z","updated":"2022-05-24T16:14:49.530Z","comments":true,"path":"posts/748fe819.html","link":"","permalink":"https://ysh-lr.github.io/posts/748fe819.html","excerpt":"","text":"软件测试PPT概念 注意敏捷测试和传统测试的区别: 敏捷测试:强调整个团队对测试负责(无测试的独立性);连续测试,连续的质量反馈,阶段性弱;注重速度和适应性,不断适应需求变化;强调团队之间面对面沟通,不注重对缺陷的跟踪和记录;始终以用户需求为中心,将验证和确认统一起来;注重产品本身和产品的客户价值,缺陷修复的代价小;自动化测试是敏捷测试的基础. 传统测试:独立性、阶段性明显、计划性、缺陷的跟踪和记录、由验证和确认两种活动组成、缺陷修复代价大（相关文档等等），鼓励自动化测试，但不自动化测试也不致命 阶段:计划与控制 基础设施建立 准备 说明 执行 完成 集成测试 JUnit单元测试 一些习题 CM1CM2 下面哪项活动不在软件测试范围 ？ A.需求文档评审 B.设计评审 C.代码测试 D.过程评审 软件测试的对象包括 A.目标程序和相关文档 B.源程序、目标程序、数据及相关文档 C.目标程序、操作系统和平台软件 D.源程序和目标程序 在软件开发接近完成时，执行下面哪种测试？ A.验收测试 B.α测试 C.β测试 D.系统测试 软件测试类型按开发阶段划分为 A.需求、单元、集成、验证测试 B.单元、集成、系统、验收测试 C.单元、集成、确认、验收测试 D.调试、单元、集成、用户测试 在软件质量模型中，可维护性属性不包括下面哪个子特性 A.适应性 B.易安装性 C.兼容性 D.一致性 软件质量是指 A.软件具有功能性 可靠性 B.最大限度满足用户需求 C.软件没有错误 D.软件满足用户需求的能力 可维护性 可移植性 和产品的固有特性 在所有软件缺陷中，哪类缺陷比例最高？ A.程序代码错误 B.软件设计错误 C.需求分析错误 D.其它 修复哪个阶段的软件缺陷，其成本最低？ A.需求分析阶段 B.系统设计阶段 C.程序编码阶段 D.软件发布阶段 最基础的软件测试是什么？ A.静态测试 B.动态测试 C.单元测试 D.集成测试 软件测试的主要目的是 CM3 下面哪个方法属于白盒测试方法？ A.路径测试 B.等价类 C.因果图 D.归纳测试 等价类划分法设计8位宽度数字类型数据作用户登录账号，有多少种测试用例方案？ A.2 B.3 C.4 D.6 假定X为整数类型变量，X&gt;=1并且X&lt;=10，采用边界值法进行测试，其方案是 A.1，10 B.0，1，10，11 C.0，1，2，9，10，11 D.0，11 根据输出对输入的依赖关系设计测试用例的方法是 A.路径测试 B.等价类 C.因果图 D.归纳测试 在黑盒测试中，着重检查输入条件组合的方法是 A.等价类划分法 B.边界值分析法 C.错误推测法 D.判定表法 不属于白盒测试的技术是 A.判定表法 B.判定覆盖 C.条件覆盖 D.路径覆盖 下面那种方法能够有效地检测输入条件的各种组合可能引起的错误 A.错误推测 B.等价类划分 C.判定覆盖 D.因果图 以下哪种方法不是黑盒测试用例的设计方法 A.场景法 B.边界值法 C.因果图法 D.路径法 下列几种逻辑覆盖标准中，查错能力最强的是 A.语句覆盖 B.判定覆盖 C.条件覆盖 D.条件组合覆盖 发现错误能力最弱的是 A.语句覆盖 B.判定覆盖 C.条件覆盖 D.路径覆盖 查找程序是否有内存泄露，可采用的软件测试是 A.静态测试 B.动态测试 C.单元测试 D.集成测试 CM4 从软件工程角度，软件测试分为几个阶段。 A.3 B.4 C.5 D.6 在W模型中，程序设计与下面哪项测试可以同步？ A.需求评审 B.设计评审 C.功能测试用例设计 D.单元测试 当软件开发机构具有独立的测试部门，该机构测试成熟度至少达到下面哪个级别？ A.TMM2 B.TMM3 C.TMM4 D.TMM5 按照软件测试规范，执行单元测试是由哪类人员来进行？ A.测试分析人员 B.测试人员 C.设计人员 D.编程人员 下面哪项不属于测试项目管理的内容 A.测试设计 B.单元测试 C.测试执行 D.测试结果分析 按照软件测试规范，在以下哪个测试阶段制定测试策略？ A.测试计划 B.测试设计 C.测试实施 D.测试评估 按照软件测试规范，下面哪项评审需要项目经理参加？ A.测试计划评审 B.测试用例评审 C.测试过程评审 D.测试结果评估 在敏捷测试中，应主要采用探索式测试 对 在软件开发的 W模型中，测试过程与开发过程同步进行 对 测试结果的评估应由SQA人员来完成 错 CM5 下面哪个测试内容不属于单元测试（ ） A.接口数据测试 B.局部数据测试 C.模块间时序测试 D.全局数据测试 以下关于集成测试的正确描述是（） A.在把各个模块连接起来的时候， B.一个模块的功能是否会对另一个模块 C.全局数据结构是否有问题 D.以上都是 穿越模块接口的数据是否会丢失 的功能产生不利的影响 在集成测试时，能较早发现高层模块接口错误的测试方法为。 A.自顶向下渐增式测试 B.自底向上渐增式测试 C.非渐增式测试 D.系统测试 Web应用系统负载测试中，以下哪个不是衡量业务执行效率的指标。 A.事务并发请求数 B.CPU执行占用率 C.事务吞吐量 D.事务响应时间 性能测试脚本执行，是在性能测试过程的第几阶段实施。 A.2 B.3 C.4 D.5 以下哪类系统可靠性最高。 A.单机系统 B.C/S系统 C.B/S系统 D.P2P系统 验证系统部件失效后的处理能力是属于以下哪种测试 A.系统性能测试 B.系统可靠性测试 C.系统容错测试 D.系统功能测试 下面哪种负载模式更接近实际系统运行情况 A.一次性加载 B.递增加载 C.高低变更加载 D.随机加载 下面哪种情况不是导致系统性能问题的原因 A.CPU使用率过高 B.内存泄露 C.系统响应时间长 D.连接资源稀少 以下哪个测试工具是使用最广泛的性能测试产品工具。 A.Load Runner B.Selenium C.JMeter D.Quick Test Professional CM6 下面哪项不是软件度量的目标（） A.用数据指标表明验收标准 B.分配资源时进行量化均衡 C.便于对软件质量进行评价 D.发现软件中的缺陷数量 下面哪项不是软件度量的用途? A.衡量软件过程质量 B.项目度量 C.开发人员成效度量 D.产品质量度量 下面项类质量数据不能用于评估软件稳定性? A.正确性 B.可靠性 C.可维护性 D.可用性 下面哪项活动是软件度量的阶段活动? A.识别目标 B.定义度量过程 C.数据分析与反馈 D.以上都是 软件度量的维度是下面哪项？ A.项目度量 B.产品度量 C.过程度量 D.以上都是 下面哪项工作需要SQA人员来完成？ A.需求评审 B.过程评审 C.设计评审 D.系统测试 下面哪项工作需要SQA人员来完成？ A.制定SQA计划 B.审查软件过程 C.软件测试过程监督 D.以上都是 测试计划不包括下面哪项工作？ A.测试计划安排 B.测试风险识别 C.测试流程审计 D.测试资源安排 SQA在项目早期要根据项目计划制定与其对应的SQA计划 对 SQA是贯穿整个软件过程的第三方独立审查活动 对 1.针对电子科技大学信息门户的“密码找回”界面的邮箱输入域进行验证， 采用等价划分法设计相应的测试用例，包括尽量多的无效等价类。 等价类划分 有效等价类 无效等价类 含有@符号 (1) 不含@符号 (2) @后面的内容为std.uestc.edu.cn (3) @后面的格式不是std.uestc.edu.cn AND@后面的格式不是uestc.edu.cn(5) @后面的内容为uestc.edu.cn(4) 邮箱用户名由数字、字母或下划线组成(6) 邮箱用户名含有除字母、数字、下划线以外的特殊字符(7) 用户名必须由字母或数字开头(8) 用户名不是由字母或数字开头(9) 测试用例 序号 测试用例 覆盖等价类 输出 1 zyh@uestc.edu.cn (1)(4)(6)(8) 正确 2 zyh@std.uestc.edu.cn (1)(3)(6)(8) 正确 3 zyhstd.uestc.edu.cn (2)(4)(6)(8) 错误 4 zh@163.com (1)(5)(6)(8) 错误 5 zyh#@std.uestc.edu.cn (1)(3)(7)(8) 错误 6 __yh@std.uestc.edu.cn (1)(3)(6)(9) 错误 2.综合运用边界值方法和等价类方法，针对三角形问题设计相应的测试用例。假定输入三个整数（a、b、c）作为边，分别满足一般三角形、等腰三角形和等边三角形。 1）判断一般三角形的有效等价类是什么? 2）判断一般三角形的无效等价是什么? 3）判断等腰三角形的有效等价类是什么? 4）判断等腰三角形的无效等价类是什么? 5）判断等边三角形的有效等价类是什么? 6）判断等边三角形的无效等价类是什么? 等价类划分 输入条件 有效等价类 无效等价类 是否为三角形 a&gt;0(1) a≤0(7) b&gt;0(2) b≤0(8) c&gt;0(3) c≤0(9) a+b&gt;c(4) a+b≤c(10) b+c&gt;a(5) b+c≤a(11) a+c&gt;b(6) a+c≤b(12) 是否为等腰三角形 a = b(13) (a≠b)and(b≠c)and(c≠a) (16) b = c(14) c = a(15) 是否为等边三角形 (a=b)and(b=c) (17) a≠b(18) a≠c(19) b≠c(20) 测试用例设计 序号 (a,b,c) 覆盖等价类 输出 1 (3,4,5) (1)(2)(3)(4)(5)(6) 一般三角形 2 (0,1,2) (7) 不能构成三角形 3 (1,0,2) (8) 不能构成三角形 4 (1,2,0) (9) 不能构成三角形 5 (1,2,3) (10) 不能构成三角形 6 (1,3,2) (12) 不能构成三角形 7 (3,1,2) (11) 不能构成三角形 8 (2,2,1) (1)(2)(3)(4)(5)(6)(13) 等腰三角形 9 (1,2,2) (1)(2)(3)(4)(5)(6)(14) 等腰三角形 10 (2,1,2) (1)(2)(3)(4)(5)(6)(15) 等腰三角形 11 (3,4,5) (1)(2)(3)(4)(5)(6)(16) 非等腰三角形 12 (1,1,1) (1)(2)(3)(4)(5)(6)(17) 等边三角形 13 (2,2,1) (1)(2)(3)(4)(5)(6)(19)(20)(13) 非等边三角形 14 (1,2,2) (1)(2)(3)(4)(5)(6)(18)(19)(16) 非等边三角形 15 (2,1,2) (1)(2)(3)(4)(5)(6)(15)(18)(20) 非等边三角形 (1) 、(1)(2)(3)(4)(5)(6) (2)、(7)(8)(9)(10)(11)(12) (3)、(1)(2)(3)(4)(5)(6)(13)(14)(15) (4)、(7)(8)(9)(10)(11)(12)(16) (5)、(1)(2)(3)(4)(5)(6)(17) (6)、(7)(8)(9)(10)(11)(12)(18)(19)(20) 3.系统的年、月、日数据由Y、M、D单元来存储相应值，若要测试NextData（Y,M,D）函数，采用判定表方法设计相应的测试用例。 M1={m=1,3,5,7,8,10} M2={m=4,6,9,11} M3={m=12} M4={m=2} D1={1≤D≤27} D2={D=28} D3={D=29} D4={D=30} D5={D=31} Y1={Y是闰年} Y2={Y是平年} 1 2 3 4 5 6 7 8 条件 Y Y1,Y2 Y1,Y2 Y1,Y2 Y1,Y2 Y1,Y2 Y1,Y2 Y1,Y2 Y1,Y2 M M2 M2 M2 M1 M1 M3 M3 M4 D D1,D2,D3 D4 D5 D1,D2,D3,D4 D5 D1,D2,D3,D4 D5 D1 动作 不可能 0 0 1 0 0 0 0 0 D+1 1 0 0 1 0 1 0 1 D复位 0 1 0 0 1 0 1 0 M+1 0 1 0 0 1 0 0 0 M复位 0 0 0 0 0 0 1 0 Y+1 0 0 0 0 0 0 1 0 续: 9 10 11 12 13 条件 Y Y1 Y2 Y1 Y2 Y1,Y2 M M4 M4 M4 M4 M4 D D2 D2 D3 D3 D4,D5 动作 不可能 0 0 0 1 1 D+1 1 0 0 0 0 D复位 0 1 1 0 0 M+1 0 1 1 0 0 M复位 0 0 0 0 0 Y+1 0 0 0 0 0 测试用例设计: 序号 (Y,M,D) 预期输出 1 (2022,3,11) 2022年3月12日 2 (2022,4,30) 2022年5月1日 3 (2022,4,31) 不可能 4 (2022,1,20) 2022年1月21日 5 (2022,1,31) 2022年2月1日 6 (2022,12,18) 2022年12月19日 7 (2022,12,31) 2023年1月1日 8 (2022,2,2) 2022年2月3日 9 (2024,2,28) 2024年2月29日 10 (2022,2,28) 2022年3月1日 11 (2024,2,29) 2024年3月1日 12 (2022,2,29) 不可能 13 (2022,2,31) 不可能 4.针对某机构人员管理的业务规则需求： 1）年薪制员工：严重过失，扣年终风险金的4%；过失，扣年终风险金的2%。 2）非年薪制员工：严重过失，扣当月薪资的8%；过失，扣当月薪资的4%。 请绘制出因果图和判定表，并给出相应的测试用例。 C1:是年薪制员工 C2:严重过失 C3:是非年薪制员工 C4:过失 E1:扣年终风险金的4% E2:扣年终风险金的2% E3:扣当月薪资的8% E4:扣当月薪资的4% 因果图: 判定表: 序号 1 2 3 4 5 6 原因 C1 1 1 0 0 1 0 C2 1 0 1 0 0 0 C3 0 0 1 1 0 1 C4 0 1 0 1 0 0 结果 E1 1 0 0 0 0 0 E2 0 1 0 0 0 0 E3 0 0 1 0 0 0 E4 0 0 0 1 0 0 测试用例: 序号 输入 输出 1 年薪制员工,严重过失 扣年终风险金的4% 2 年薪制员工,过失 扣年终风险金的2% 3 非年薪制员工,严重过失 扣当月薪资的8% 4 非年薪制员工,过失 扣当月薪资的4% 5 年薪制员工,无过失 不扣 6 非年薪制员工,无过失 不扣 5.测试一个登录页面在不同浏览器和语言下的功能正确性，其输入条件如下: 1）输入项（账号、密码） 2）浏览器（IE、chrome、FireFox、360） 3）语言（中文、英文） 请问进行完整组合的兼容性测试需要多少个测试用例？采用成对组合的兼容性测试需要多少个测试用例？给出成对组合测试用例表。 答:完整组合的兼容性测试需要 32个测试用例 ​ 采用成对组合的兼容性测试需要10个测试用例 序号 账号 密码 浏览器 语言 1 填值 填值 IE 中文 2 填值 空值 chrome 英文 3 填值 填值 FireFox 中文 4 填值 空值 360 英文 5 空值 空值 IE 英文 6 空值 填值 chrome 中文 7 空值 空值 FireFox 英文 8 空值 填值 360 中文 9 空值 填值 IE 英文 10 空值 空值 chrome 中文","categories":[],"tags":[{"name":"软件测试","slug":"软件测试","permalink":"https://ysh-lr.github.io/tags/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95/"}]},{"title":"计算机操作系统(二)","slug":"post-4","date":"2022-01-20T10:06:40.000Z","updated":"2022-05-24T15:33:32.034Z","comments":true,"path":"posts/8c2e937.html","link":"","permalink":"https://ysh-lr.github.io/posts/8c2e937.html","excerpt":"","text":"进程的描述与控制前趋图与程序执行前趋图用于描述程序执行的先后顺序。 前趋图中的每个结点可用来表示一个进程或程序段，乃至一条语句，结点间的有向边则表示两个结点之间存在的偏序或前趋关系。 前趋图中不允许有循环 合理前趋图： 如上图，存在以下前趋关系： P1→P2,P1→P3,P1→P4,P2→P5,P3→P5,P4→P6,P4→P7,P5→P8,P6→P8,P7→P9,P8→P9 或表示为： P={P1,P2,P3,P4,P5,P6,P7,P8,P9} ={(P1,P2),(P1,P3),(P1,P4),(P2,P5),(P3,P5),(P4,P6),(P4,P7),(P5,P8),(P6,P8),(P7,P9),(P8,P9)} 不正确的前趋图（具有循环）： S2→S3，S3→S2，显然是无法实现的。 程序顺序执行 程序顺序执行时的特征： 顺序性 指处理机严格地按照程序所规定的顺序执行，即每一操作必须在下一个操作开始之前结束； 封闭性 指程序在封闭的环境下运行，即程序运行时独占全机资源，资源的状态（除初始状态之外）只有本程序才能改变它，程序一旦开始执行，其执行结果不受外界因素影响； 可再现性 指只要程序执行时的环境和初始条件相同，当程序重复执行时，不论它是从头到尾不停顿地执行，还是“停停走走”地执行，都可获得相同的结果。 程序并发执行以打印为例：由输入程序（I）、计算程序（C）、打印程序（P）组成，单个打印作业存在Ii→Ci→Pi这样的顺序执行的前趋关系，但对于多个打印作业如果全部按照顺序方式执行依次输入，则对于CPU利用率较小，故采用并发方式执行： 由图可以看出Pi-1和Ci以及Ii+1之间不存在前趋关系，可以并发执行。 程序并发执行时的特征 间断性 程序在并发执行时，由于它们共享系统资源，以及为完成同一项任务而相互合作，致使在这些并发程序之间形成了相互制约的关系。 失去封闭性 资源共享 不可再现性 由于失去封闭性，导致其失去了不可再现性，即使执行的环境和初始条件相同也不一定得到相同结果。与执行速度有关。 进程的描述 ①进程是程序的一次执行； ②进程是一个程序及其数据在处理机上顺序执行时所发生的活动； ③进程是具有独立功能的程序在一个数据集合上运行的过程，它是系统进行资源分配和调度的一个独立单位。 进程是进程实体的运行过程，是系统进行资源分配和调度的一个独立单位。 为什么要引入进程这个概念？所有事物的发展都是从简单到复杂，而在最初，程序执行往往是连续的、封闭的、可再现的，也就是说顺序执行，这也是通常的程序具有的一般性质，那么如何使程序能够并发执行，并且对这种并发加以描述和控制呢？就引入进程这一概念，所以进程往往具有程序并发执行的一些特征。 PCB 为了使参与并发执行的每个程序（含数据）都能独立运行，在操作系统中必须为之配置一个专门的数据结构，称为进程控制块（PCB） 由程序段、相关的数据段和PCB三部分就构成了进程实体，一般情况下简称为进程。 创建进程：创建进程实体中的PCB 撤销进程：撤销进程的PCB 进程的特征 进程 程序 ①动态性 进程的实质是进程实体的执行过程，具有一定的生命期，创建（产生）—调度（执行）—撤销（消亡） 静态的 只是一组有序指令的集合，本身不具有活动的含义 ②并发性 多个进程实体同存在于内存之中，且能在同一段时间内同时运行（也是引入进程的目的所在） 程序（没有建立PCB）是不能参与并发执行的 ③独立性 进程实体是一个能独立运行、独立获得资源和独立接受调度的基本单位 凡未建立PCB的程序都不能作为一个独立的单位参与运行 ④异步性 进程按各自独立的、不可预知的速度向前推进 传统意义上的程序若参与并发执行，会产生其结果的不可再现性。 备注：针对④，为使进程在并发运行时虽具有异步性，但仍能保证进程并发执行的结果是可再现的，在OS中引进了进程的概念，并配置相应的进程同步机制。 进程的状态及转换一般而言，进程应至少处于就绪、执行、阻塞三种基本状态之一。 三种基本状态以及转换（1）就绪状态：除了CPU以外的全部资源都已经准备好。如果系统中有多个处于就绪状态的进程，通常将它们按照一定的策略（如优先级策略）排成就绪队列。 （2）执行状态：已获得CPU，正在执行的状态。 通常单处理机中只有一个进程处于执行状态；多处理机中可有多个进程处于执行状态。 （3）阻塞状态：正在执行的进程由于发生某事件（如I/O请求、申请缓冲区失败等）暂时无法继续执行的状态，亦即进程的执行受到阻塞。 此时引起进程调度，OS将处理机分配给另一个就绪进程，而让受阻进程处于暂停状态。 阻塞队列：通常根据阻塞原因不同，设置多个阻塞队列。 就绪状态→调度程序为之分配处理机→执行状态→分配给它的时间片已完成被剥夺处理机暂停执行→就绪状态 执行状态→发生某事件使进程受阻，使之无法继续执行→阻塞状态 某事件举例：进程访问某临界资源，而该资源正被其他进程访问。 创建进程以及创建状态 进程的终止与终止状态进程的终止需要两个步骤：等待操作系统进行善后处理（其他进程对其信息进行提取【保留记录】）；将其PCB清零，并将PCB空间返还系统。 终止条件： 进程到达了自然临界点 出现了无法克服的错误 被操作系统所终结 被其他有终止权的进程终结 （详见本篇进程控制部分） 被终止后的进程以后不再执行，但在操作系统中依然保留一个记录，其中保存状态码和一些及时统计数据，供其它进程收集。 挂起操作和进程状态转换 挂起：意味着此时进程处于静止状态——&gt;不能被调度/暂停执行 激活：与挂起操作相对应 由此，产生了活动就绪、静止就绪；活动阻塞、静止阻塞 引入挂起操作的原因 终端用户的需要 父进程请求 负荷调节的需要 操作系统的需要 总的来讲，是为了排查或者避免一些运行中的问题、协调进程活动。 就绪：进程在内存，准备执行 阻塞：进程在内存，等待执行 就绪挂起：进程在外存，暂时不调度 阻塞挂起：进程在外存 进程管理中的数据结构——进程表PCB PCB的作用：是一个在多道程序环境下不能独立运行的程序（含数据）成为一个能独立运行的基本单位，一个能与其他进程并发执行的进程。 （1）作为独立运行基本单位的标志 （2）能实现间断性运行方式 （3）提供进程管理所需要的信息 （4）提供进程调度所需要的信息 （5）实现与其他进程的同步与通信 进程控制块的组织方式 在一个系统中，通常可以有数十个、数百个乃至数千个PCB。为了能对它们加以有效的管理，应采用适当的方式对其进行组织。 （1）线性方式 将系统中所有PCB组织在一张表中，将该表的首址存放在内存的一个专用区域中。 优点：简单、开销小 缺点：每次查找时都需要扫描整张表，效率较低 适用于进程数目不多的系统 （2）链接方式 将具有相同状态进程的PCB分别通过PCB中的链接字链接成一个队列。 对就绪队列而言，往往按进程的优先级将PCB从高到低进行排列，将优先级高的进程PCB排在队列的前面。 （3）索引方式 系统根据所有进程状态不同，建立几张索引表，并把个索引表在内存的首地址记录在内存的一些专用单元中。在每个索引表的表目中，记录具有相应状态的某个PCB在PCB表中的地址。 进程控制操作系统内核 现代操作系统一般将OS划分为若干层次，再将OS的不同功能分别设置在不同的层次中。通常将一些与硬件紧密相关的模块（如中断处理程序等）、各种常用设备的驱动程序、运行频率较高的程序（如时钟管理、进程调度和许多模块公用的一些基本操作），都安排在紧靠硬件的软件层次中，将它们常驻内存，即通常被称为的OS内核。 目的： 便于对这些软件进行保护，防止遭受其他应用程序的破坏； 提高OS的运行效率。 功能： 支撑功能 提供给OS其他众多模块所需要的一些基本功能，以便支撑这些模块工作。 （1）中断处理 内核最基本的功能 （2）时钟管理 （3）原语操作 所谓原语，就是由若干条指令组成的，用于完成一定功能的一个过程。 与一般过程的区别：原语为“原子操作”，一个操作中所有动作要么全做，要么不做，是一个不可分割的基本单位。因此，原语在执行过程中不允许被中断。 资源管理功能 （1）进程管理 （2）存储器管理 （3）设备管理 进程的创建进程的层次结构 父进程与子进程：把创建进程的进程称为父进程，把被创建的进程称为子进程，子进程可以继续创建更多的进程。 进程间的继承关系：子进程可以继承父进程所拥有的资源（父进程打开的文件、分配到的缓冲区等）子进程被撤销时，应将其从父进程那里获得的资源归还给父进程；在撤销父进程时，也必须同时撤销其所有的子进程。进程不能拒绝其子进程的继承权。 Windows 句柄：不存在任何进程层次的概念，所有进程具有同等地位。如果一个进程创建另外的进程时获得一个句柄，其作用相当于一个令牌，可以用来控制被创建的进程。但是，这个句柄是可以进行传递的。获得句柄的进程就拥有了控制其他进程的权力。 进程图 （类似树）结点为进程。 引起创建进程的事件 （1）用户登录 （2）作业调度 （3）提供服务 （4）应用请求 进程的创建 （1）申请空白PCB （2）为新进程分配其运行所需的资源，包括各种物理和逻辑资源 （3）初始化进程控制块 ​ ①初始化标识信息（系统分配的标识符和父进程标识符） ​ ②初始化处理机状态信息，使程序计数器指向程序的入口地址，使栈指针指向栈顶 ​ ③初始化处理机控制信息，（状态：就绪/精致就绪；优先级） （4）插入队列 进程的终止引起进程终止的事件 （1）正常结束 （2）异常结束 ​ ①越界错 程序访问的存储区越出该进程区域 ​ ②保护错 进程试图去访问一个不允许访问的资源或文件或以不适当的形式进行访问 ​ ③非法指令 程序试图去执行一条不存在的指令 ​ ④特权指令错 用户试图去执行一条只允许OS执行的指令 ​ ⑤运行超时 ​ ⑥等待超时 ​ ⑦算术运算错 ​ ⑧I/O故障 进程的终止过程 （1）根据标识符，读出该进程状态 （2）终止该进程，置调度标志为真 （3）终止子进程 （4）资源归还父进程 （5）移出队列，等待其他进程搜集信息 进程的阻塞与唤醒阻塞原语：block 唤醒原语：wakeup block原语和wakeup原语必须成对使用 挂起原语：suspend 激活原语：active 引起进程阻塞或唤醒的事件 向系统请求共享资源失败 等待某种操作完成 新数据尚未到达 等待新任务的到达 进程阻塞的过程 阻塞是进程自身的一种主动行为。正在执行的进程，若发生上述事件，进程便通过调用阻塞原语block将自己阻塞。 状态设置——插入队列——重新调度 进程唤醒的过程 调用唤醒原语wakeup 移出队列——状态设置——插入队列 进程同步进程同步的基本概念我们还记得多道批处理时是不可再现的，这对我们检查、定位、修正异常带来了麻烦，进程和进程同步机制就是为了使多道批处理具有可再现性。 进程同步机制的主要任务，是对多个相关进程在执行次序上进行协调，使并发执行的诸进程之间能按照一定的规则（或时序）共享系统资源，并能很好的相互合作，从而使程序的执行具有可再现性。 1）间接相互制约 由于共享系统资源形成的相互制约关系 2）直接相互制约 未完成某任务而建立的多个进程，源于彼此间相互合作的制约关系。 临界资源 采取互斥方式，实现对这类资源的共享 访问临界资源的代码段称为临界区。","categories":[],"tags":[{"name":"操作系统","slug":"操作系统","permalink":"https://ysh-lr.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"}]},{"title":"操作系统学习笔记(一)","slug":"post-3","date":"2022-01-14T11:51:44.000Z","updated":"2022-01-17T07:53:45.878Z","comments":true,"path":"posts/392e0872.html","link":"","permalink":"https://ysh-lr.github.io/posts/392e0872.html","excerpt":"","text":"计算机操作系统(一) 操作系统是配置在计算机硬件上的第一层软件,是对硬件系统的首次扩充,其主要作用是管理好这些设备,提高它们的利用率和系统的吞吐量,并为用户和应用程序提供一个简单的接口,便于用户使用。 操作系统的目标、作用及发展过程操作系统的目标 方便性 裸机使用→机器语言 配置OS→高级语言编写的程序或OS提供的命令→方便用户、易学易用 有效性 提高系统资源的利用率 提高系统的吞吐量 可扩充性 为适应计算机硬件、体系结构以及计算机应用发展的要求。 无结构→模块化结构→层次化结构→微内核结构 开放性 硬件与软件的兼容性 系统能遵循世界标准规范→统一的开放环境以实现应用的可移植性与互操作性 不同设备间可以通过网络集成，正确有效的协同工作 操作系统的作用 作为用户与计算机硬件系统之间的接口； （1）命令方式 （2）系统调用方式 （3）图标—窗口方式 作为计算机系统资源的管理者； 计算机系统资源（四类）：处理机、存储器、I/O设备、文件（数据和程序） 实现了对计算机资源的抽象； 操作系统的发展过程人工操作→单道批处理→多道批处理→分时系统→实时系统（优缺点） 操作系统的基本特性 并发 · 并行与并发 并行性：两个或多个事件在同一**时刻**发生。 并发性：两个或多个事件在同一**时间间隔**内发生。 多道程序环境下：宏观上有多个程序在同时运行，但在单处理机系统中，每一时刻仅能有一道程序执行→微观上为分时交替进行→*并发**。但是如果有多个处理机，这些可以并发执行的程序可以分配给不同处理机执行→并行***，实现微观意义上的同时进行。 · 进程与线程 未引入进程：计算程序与I/O程序（CPU空闲）间顺序执行。对计算程序和I/O程序分别设立进程：可以并发执行。 引入进程：程序为静态的。进程为程序的执行→提高系统资源利用率，增加系统的吞吐量。 引入线程：进程的更小的可执行单位，一个进程可包含若干个进程。 共享 一般情况下共享与操作系统环境下的共享其含义并不相同：前者未限定借阅者必须在同一时间或间隔和同一地点进行共享；而在OS环境下的共享是指系统中的资源可供内存中多个并发执行的进程(线程)共同使用。 这里在宏观上既限定了时间（进程在内存期间内），也限定了地点（内存）。 由于资源属性的不同，进程对资源共享的方式也不同，目前主要有以下两种资源共享方式：互斥共享方式系统中的某些资源，如打印机、磁带机，虽然它们可以提供给多个进程(线程)使用，但为使所打印或记录的结果不致造成混淆，应规定在一段时间内只允许一个进程(线程)访问该资源，我们把这种资源共享方式称为互斥式共享。临界资源或独占资源：一段时间内只允许一个进程访问的资源。计算机系统中的大多数物理设备，以及某些软件中所用的栈、变量和表格，都属于临界资源，它们要求被互斥地共享。同时访问方式允许在一段时间内由多个进程 “同时”对它们进行访问。这里所谓的“同时”往往是宏观上的，而在微观上，这些进程可能是交替地对该资源进行访问。并发和共享是多用户(多任务)OS的两个最基本的特征。它们又是互为存在的条件。 虚拟 在OS中,把通过某种技术将一个物理实体变为若干个逻辑上的对应物的功能称为”虚拟” 。前者为实体，后者则是虚的，是用户感觉上的东西。相应的，把用于实现虚拟的技术称为虚拟技术。 “空分复用”或”时分复用”技术,将一条物理信道变为若干条逻辑信道. 时分复用技术 利用某设备为一用户服务的空闲时间，又转去为其他用户服务，使设备得到最充分的利用。 ⑴虚拟处理机技术：在虚拟处理机技术中，是通过多道程序设计技术，让多道程序并发执行的方法，来分时使用一台处理机的。（宏观）⑵虚拟设备技术：将一台物理I/O设备虚拟为多台逻辑上的I/O设备，并允许每 个用户占用一台逻辑上的I/O设备，这样便可使原来仅允许在 一段时间内由一个用户访问的设备(即临界资源)，变为在一 段时间内允许多个用户同时访问的共享设备。 在操作系统中，虚拟的实现主要是通过分时复用的方法。显然，如果 n 是某物理设备所对应的虚拟的逻辑设备数，则虚拟设备的平均速度必然等于或低于物理设备速度的1 / n 。 空分复用技术 利用存储器的空闲空间分区域存放和运行其他的多道程序，以此来提高内存的利用率。 类似分时复用技术，虚拟设备平均占用空间必然也低于或等于1/n。 异步 由于资源等因素的限制，使进程的执行通常都不是“一气呵成”， 而是以“停停走走”的方式运行。内存中的每个进程在何时能获得处理机运行，何时又因提出某种资源请求而暂停，以及进程以怎样的速度向前推进，每道程序总共需多少时间才能完成，等等，都是不可预知的。由于各用户程序性能的不同，比如，有的侧重于计算而较少需要 I/O；而又有的程序其计算少而I/O多，这样，很可能是先进入内存的作业后完成；而后进入内存的作业先完成。或者说，进程是以人们不可预知的速度向前推进，此即进程的异步性。尽管如此，但只要运行环境相同，作业经多次运行，都会获得完全相同的结果。因此，异步运行方式是允许的，是操作系统的一个重要特征。 操作系统的主要功能 处理机管理功能 进程控制 为作业创建进程、撤销或终止已结束的进程、以及控制进程在运行中的状态转换。 进程同步 ①进程互斥方式②进程同步方式 进程通信 实现相互合作进程之间的信息交换 调度 包括作业调度和进程调度两步：作业调度：将作业调入内存后，分别为他们建立进程；进程调度：按照一定的算法选出一个进程 存储器管理功能 内存分配 为每道程序分配内存空间；提高存储器的利用率；允许正在运行的程序申请附加的内存空间，以适应程序和数据动态增长的需要。 ​ 静态分配 作业的内存空间是在作业装入是确定的，装入后的运行期间不允许改作业申请新的内存空间或者改变内存空间（即不允许作业在内存中“移动”）。 ​ 动态分配 允许在运行期间申请新的内存空间和移动。 内存保护 确保每道用户程序都仅在自己的内存空间内运行，彼此互不干扰。 ​ 绝不允许用户程序访问操作系统的程序和数据，也不允许用户程序转移到非共享的其它用户程序中去执行。 地址映射 逻辑地址与物理地址 内存扩充 逻辑上扩充内存容量（虚拟） 设备管理功能 缓冲管理 ①缓和I/O设备和CPU之间速度不匹配的矛盾，提高CPU利用率。提高系统的吞吐量。 ​ ②改善系统的性能 设备分配 设备处理 文件管理功能 缓冲管理 设备分配 设备处理 操作系统与用户之间的接口 用户接口 程序接口 （现代）系统安全 （现代）网络的功能和服务 （现代）支持多媒体 操作系统结构设计模块化结构设计 模块独立性标准:内聚性,耦合度——高内聚，低耦合。 模块-接口法优点： ​ 提高OS设计的正确性、可理解性和可维护性。 ​ 增强OS的可适应性。 ​ 加速OS的开发过程。 分层式结构 优点：易保证系统的正确性易拓充易维护 缺点：系统效率降低 客户/服务器模式面向对象微内核","categories":[],"tags":[{"name":"操作系统","slug":"操作系统","permalink":"https://ysh-lr.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"}]},{"title":"机器学习Day1","slug":"post-2","date":"2022-01-14T01:05:36.000Z","updated":"2022-01-14T01:06:55.040Z","comments":true,"path":"posts/8625e497.html","link":"","permalink":"https://ysh-lr.github.io/posts/8625e497.html","excerpt":"","text":"[TOC] 机器学习 Day.1 一般地，令D = {x,x2….x.m}表示包含m个示例的数据集，每个示例由d个属性描述,则每个示例Xi= (xi1;xi2;……;xid) 是d维样本空间X中的一个向量, xi∈x,其中xij是xi在第j个属性上的取值(例如上述第3个西瓜在第2个属性上的值是“硬挺”), d称为样本xi的“维数”(dimensionality). 基础概念 （属性1 = 取值，属性2 = 取值，……，属性3=取值）——一个示例 {示例1，示例2，……，示例3}——数据集 每条示例中所有的属性分别看作一根坐标轴张成==属性空间/样本空间==，则可以把一个示例称为==特征向量== graph LR A[预测任务] --&gt;Z(监督学习) A --&gt;Y(无监督学习) Y--&gt;X(聚类) Z --&gt;B(离散型) B --&gt; C(分类) C --&gt;|仅涉及两个类别|F(二分类) F --&gt;M(y = -1,+1) C --&gt;|涉及多个类别|G(多分类) G --&gt;L(y的绝对值&gt;2) Z --&gt;D(连续型) D --&gt;E(回归) E --&gt;N(y=R) 泛化能力：学得模型适用于新样本的能力。 假设空间规模大小：搜索目标是找到能够将训练集中的瓜判断正确的假设。假设的表示一旦确定，假设空间及规模大小也就确定了：（属性1的表示个数属性2的……属性n的表示个数==+1==） 注：在考虑取值的时候，要考虑==该属性不影响结果==（用通配符*表示）、==不存在要求结果==（输出结果为空）两种容易忽略的情况。 版本空间：根据假设的表示得到假设空间，剔除与样本集中正例（某事发生）不一致的假设向量和与负例一致的假设向量后剩余向量构成版本空间。 注意：含通配符的假设向量可能会和负例一致，一定要谨慎！不要多/少 偏好：1.尽可能特殊（适用情况尽可能少）；2.尽可能一般（适用情况尽可能多）；…… 怎么判断是一般还是特殊？ ​ 数据集中符合新样本属性的各类示例输出结果中多的为一般，少的为特殊。 ==引导算法确立“正确的”偏好的原则== “奥卡姆剃刀”：若有多个假设与观察一致，则选最简单的那个","categories":[],"tags":[{"name":"西瓜书 笔记","slug":"西瓜书-笔记","permalink":"https://ysh-lr.github.io/tags/%E8%A5%BF%E7%93%9C%E4%B9%A6-%E7%AC%94%E8%AE%B0/"}]},{"title":"Java复习细节拾遗","slug":"post-1","date":"2022-01-13T13:43:03.000Z","updated":"2022-01-15T02:14:58.710Z","comments":true,"path":"posts/1486b1bb.html","link":"","permalink":"https://ysh-lr.github.io/posts/1486b1bb.html","excerpt":"","text":"[TOC] Java复习(细节拾遗)前三章的一点点小知识 Java语言数据中的数值类型都是有符号(正负号)的，在贮存数值类型的数据时，其最高位用来表示数据的正负号。 简单类型的变量被声明时，存储空间也同时被分配。该贮存空间只占用一个单一贮存单元。对简单类型变量访问则直接可以得到它的数据。 引用类型声明变量时，是==不会==为变量(即对象)分配存储空间。它们声明的变量不是数据本身，而是数据的引用(reference)，需用new运算符来为引用类型的变量分配贮存空间，在运行时动态的分配内存大小 .例如:==数组== 整型类型和boolean类型之间不能相互转换 switch所用的表达式为int类型相容的数据表达式，它可以是byte、short、char或者int类型的值，特别要指出的是不能是布尔型的值。 continue的作用与break类似,主要用于循环,所不同的是break会结束程序块的执行,而continue只会结束其之后程序块的语句,并跳回循环程序块的开头继续下一个循环,而不是离开循环 方法中引用类型形参改变实参也会改变(引用类型变量指向的是内存地址,形参和实参指向的是同一内存地址.所以方法对引用型变量的改变会保存下来. 第四章 面向对象(上)类中定义:成员变量;方法中定义:局部变量。同名变量，方法调用的是==局部变量==。——为避免该情形，提供了==this==关键字。 This关键字 表示当前对象，指向调用的对象本身（成员变量、成员方法） println(this)与println(p)输出的是堆地址； 相等 不相等 This的三种用法： 使用This调用类中属性（常用于带参构造方法中） 调用成员方法 调用构造方法：this([实参列表]) 在构造方法中，使用this调用构造方法的语句==必须位于首行==，==且只能出现一次== this调用构造方法时，一定要留一个出口，即至少存在一个构造方法不使用this调用其他构造方法。 声明一个引用变量：==变量名在栈内存中==（如下图,p1,p2） new一个对象：==为对象在堆中分配内存空间== 一个对象能够被多个变量所引用 垃圾回收 动态存储管理技术，由Java虚拟机自动回收垃圾对象所占的内存空间 在setXxx()方法中，如果对属性有条件制约，那么调用set方法输入被过滤范围内的数值时，原属性仍为初始化值（String:null，int:0） 类未定义构造方法时，系统会自动提供一个空参构造器，但自己定义构造方法后，系统==不会==再提供空参构造器。 重载：多个构造方法，但是参数列表不同。 static关键字 使用static关键字修饰的成员变量称为静态变量或类变量，它被类的所有对象共享，可以通过==类名==直接访问。 未使用static修饰的变量为实例变量，属于具体对象独有，只能通过引用变量访问。 输出：1（初始化为0） 输出：5 注：static关键字在修饰变量的时候只能修饰成员变量，==不能修饰方法中的局部变量== 使用static修饰的成员方法，称为静态方法，无需创建类的实例（对象）就可以调用静态方法，其可以通过类名调用。 静态方法==只能访问类的静态成员（静态变量、静态方法）==，不能访问类的实例成员。因为实例成员属于对象，要创建对象才能访问。 内部类 是外部类的一个成员，内部类可以访问外部类的任何成员（包括私有成员:外部类名.this.外部类私有成员变量），外部类不能直接访问内部类成员。 可为静态，可以用Protect和private修饰（外部类不能，只能public和默认） 经Java编译器编译后生成的外部类与内部类是独立的 在外部类中访问内部类需要==创建内部类的对象==使用内部类的对象访问其中成员。 若在外部类==外==访问内部类，则需要通过外部类对象去创建内部类对象 外部类名.内部类名 引用变量名=new 外部类名().内部类名() 第五章 面向对象（下）继承方法重写：子类重写的方法不能拥有比父类方法更加严格的访问权限。 重载：在同一个类中，方法名相同，但参数个数或参数类型不同 重写：子类与父类之间，方法名、返回值类型和参数列表相同。 子类中访问父类里被重写的方法：super 在一个构造方法中调用重载的另一个构造方法使用关键字：this；在子类构造方法中调用父类构造方法使用关键字supper（同样要位于构造方法第一行） 子类中如果没有显式的调用父类的构造方法，将自动调用父类的空参构造方法（若父类没有空参构造方法，则会报错） final关键字 用它修饰的类、方法、变量不可以修改：类不能被继承；方法不能被子类重写；变量为常量，初始化后不能再修改。 Java虚拟机不会为final修饰的变量默认初始化——==用final修饰成员变量时，需要在声明时立即初始化，或在构造方法中初始化== 可以修饰引用变量：表示只能是中引用一个对象，但对象的内容可以更改。 抽象类 抽象方法：不含方法体的方法。 包含抽象方法的类==必须是抽象类==，抽象类可以==不包含任何抽象方法== 抽象类不可以实例化（不能用new创建对象）——必须通过子类继承抽象类去实现抽象方法。(具体子类==必须实现抽象父类中的所有方法==,否则子类必须声明为抽象类. 抽象方法（不是抽象类!注意区分）不能用static（可通过类名访问）、final（不能重写）、private（==子类不能访问带private的抽象方法==）关键字修饰。 注：子类并==不是==能够继承父类的所有属性和方法，子类只能够继承父类的非私有成员。 抽象类可以定义构造方法与成员变量！！！——如果抽象类有构造方法（构造方法允许有方法体），则子类的构造方法中必须先对抽象类进行构造【supper(参数列表)】==子类构造时会默认调用父类中无参构造方法==。 接口（interface变量默认为public static final,方法默认为public abstract。 implements实现接口（允许==多个== 区别点 接口 抽象类 含义 接口通常用于描述一个类的外围能力，而不是核心特征 抽象类定义了他的子类的核心特征。 方法 接口只提供方法声明 抽象类可以提供完整方法（==抽象类不一定含有抽象方法==）、默认构造方法以及用于覆盖的方法声明。 变量 只包含public static final常量，必须在声明时初始化 可以包含实例变量和静态变量 多重继承 一个类可以继承多个接口 一个类只能继承一个抽象类 实现类 类可以实现多个接口 类只从抽象类派生,必须重写 多态 同一操作作用于不同的对象可以有不同的解释. 方法的实现是由变量的==实际类型==决定的。 多态体现的是==向上转型==,也称隐式转换。 向下转型必须强制转换： Person p=new Child();//向上转型 Parent o =(Parent)p;//向下转型 equals类默认比较的是引用变量地址（==也是）；String类中的equals被重写为比较两字符串内容是否相等。 多线程==线程的安全性问题==1.同步代码块 IO流FileInputStreamfinally不能直接访问try中的内容,为防止程序中断后,流无法释放占用资源,==一定要将close方法写在finally中==,流要定义在==try外面==","categories":[],"tags":[{"name":"java","slug":"java","permalink":"https://ysh-lr.github.io/tags/java/"}]},{"title":"LeetCode No.7","slug":"post","date":"2022-01-13T13:30:26.000Z","updated":"2022-01-15T02:08:09.697Z","comments":true,"path":"posts/c5bc31ac.html","link":"","permalink":"https://ysh-lr.github.io/posts/c5bc31ac.html","excerpt":"","text":"[TOC] LeetCode题解（7.整数反转）题面 给你一个 32 位的有符号整数 x ，返回将 x 中的数字部分反转后的结果。 如果反转后整数超过 32 位的有符号整数的范围 [−231, 231 − 1] ，就返回 0。假设环境不允许存储 64 位整数（有符号或无符号）。 示例 1： 输入：x = 123输出：321 示例 2： 输入：x = -123输出：-321 示例 3： 输入：x = 120输出：21 示例 4： 输入：x = 0输出：0 提示： -231 &lt;= x &lt;= 231 - 1 分析整数反转算是烂大街的（不是）考题了，其实看到反转第一反应是栈……但是对付整数来讲略微小题大做。 最无脑的反转方法就是x/10,x%10,x%100……得到x每一位上的数字然后再乘回去，从这种无脑的思想中其实可以总结出一个公式：result = result*10+x%10;x=x/10; 构成循环，循环的终止条件自然就是x==0，这种情况，while最合适了。 这里记录一下我犯过的愚蠢错误： 倒在单词拼写上的女人：while我再也不会拼错啦 x/10和x%10:前者是得到去除个位后的数字，后者是取当前个位数字（老是搞混，呜呜 但是！这道题最膈应人的地方并不是如何把整数反转（因为它实在是太简单了 这道题的重头应该在于==特殊情况的输出如何进行判断== 如题，我们最后的结果result在超过一定范围后要输出0，所以显然我们要对result取值进行判断，但是==假设环境不允许存储 64 位整数（有符号或无符号）。== ？？？ 这怎么搞 环境不允许存储64位整数意味着无法写该范围————怎么处理？ 这时候想到了long 64位，如果将64位long强转为int也相等……OK class Solution { public int reverse(int x) { long result = 0; while(x!=0){ result=result*10+x%10; x=x/10; } if((int)result == result){ return (int)result; } else return 0; } }","categories":[],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://ysh-lr.github.io/tags/LeetCode/"}]}],"categories":[],"tags":[{"name":"数据库","slug":"数据库","permalink":"https://ysh-lr.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"软件安全","slug":"软件安全","permalink":"https://ysh-lr.github.io/tags/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8/"},{"name":"软件测试","slug":"软件测试","permalink":"https://ysh-lr.github.io/tags/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95/"},{"name":"操作系统","slug":"操作系统","permalink":"https://ysh-lr.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"},{"name":"西瓜书 笔记","slug":"西瓜书-笔记","permalink":"https://ysh-lr.github.io/tags/%E8%A5%BF%E7%93%9C%E4%B9%A6-%E7%AC%94%E8%AE%B0/"},{"name":"java","slug":"java","permalink":"https://ysh-lr.github.io/tags/java/"},{"name":"LeetCode","slug":"LeetCode","permalink":"https://ysh-lr.github.io/tags/LeetCode/"}]}